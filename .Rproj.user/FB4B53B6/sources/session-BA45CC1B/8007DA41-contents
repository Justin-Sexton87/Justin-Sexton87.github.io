---
title: "Downscaled weather forecasts for predicting upcoming irrigation events in the Burdekin sugarcane-growing region"
output:
  word_document: 
    reference_docx: "ASSCT-template1.docx"
  html_document:
    theme:
        version: 5
        bootswatch: 'journal'
author: "J. Sexton, A. Schepen, B. Philippa, Y. Everingham, B. Melville, S. Attard, M. "
date: "`r format(Sys.time(), '%d %B, %Y')`"
signature: "justin.sexton1@jcu.edu.au"
abstract: "Increased pressure to reduce pesticide and nutrient run-off from sugarcane farms to the GBR. Reducing applications can reduce profitability which can affect long term stability of the industry. Weather forecasts in conjunction with crop growth models, have been used to provide forecasts of upcoming irrigation requirements.  However, in order for forecast crop conditions to be meaningful to growers, the weather forecasts must be of appropriate skill and relevant to the local conditions. Previous irrigation forecast and scheduling tools have largely targeted Optimization of irrigation amount for today. An alternative to optimized forecasts may be to provide forecast probabilities for when or if the next irrigation event is likely to occur. In this study we use locally downscaled short range weather forecasts and the APSIM crop model to produce a probability forecast of an irrigation occurring over the next seven days. Weather forecasts are downscaled for five climate zones identified in the sugarcane-growing region around Ayr, Queensland, Australia. Models produce an ensemble of 200 forecasts of rainfall, maximum temperature and minimum temperature each day. Forecast skill for rainfall and temperature are compared to 1. Raw forecasts and 2. Naïve forecast approach. For all zones the downscaled forecasts show lower CRPS values at all lead times compared to the naïve and raw forecasts. For maximum temperature the downscaled forecast had lower CRPS values than either the naïve or raw forecasts but tended to approach the naïve forecast skill at longer lead times. For minimum temperature, both the raw and downscaled forecasts outperformed the naïve forecast at all lead times except in the Ayr/Brandon zone (zone 5). Based on AUC scores, the downscaled model tended to outperform the naïve and raw forecasts at classifying both wet days (>0.1 mm) and irrigation days. However, the downscaled model tended to have poorer Sensitivity than the other models, especially at longer lead times.  By changing the cut-off point for the probabilistic downscaled model, classification Sensitivity could be improved. Using locally specific forecasts produces captures uncertainty in upcoming rainfall in relation to irrigation requirements. This is an improvement over assumptions of no rainfall as it can be used to reduce the chances of false positive irrigation events. Decisions around irrigation scheduling can be made based on risk profile of the user as forecast irrigation events are probabilistic."
fig_caption: yes
bibliography: "Skill_paper.bib"
editor_options: 
  chunk_output_type: console
---


```{r packages, echo=F, warning=F,message=F}
library(tidyverse)
library(Rcpp)
library(tidync)
library(foreach)
library(doParallel)
library(rgdal)
library(leaflet)
library(webshot)
library(mapview)
library(reticulate)


```

```{r zone data, echo=F, message=F,warning=F}

locations = list(
  c(
    "region"= "Burdekin",
    "zone"= 1,
    "name"= "Giru/Barratta",
    "zonename"= "blue",
    "elevation"= 10,
    "coordinates"= c(
      c(147.05, -19.55),
      c(147.10, -19.60),
      c(147.10, -19.55),
      c(147.10, -19.50),
      c(147.15, -19.65),
      c(147.15, -19.60),
      c(147.15, -19.55),
      c(147.20, -19.60),
      c(147.20, -19.55),
      c(147.25, -19.60),
      c(147.25, -19.55),
      c(147.30, -19.55),
      c(147.30, -19.50),
      c(147.10, -19.65),
      c(147.05, -19.65),
      c(147.05, -19.60),
      c(147.05, -19.50),
      c(147.15, -19.50),
      c(147.20, -19.50)
    ),
    "geometry"= c(
      "type"= "MultiPolygon",
      "coordinates"= c(
        c(
          c(
            c(147.225, -19.525),
            c(147.275, -19.525),
            c(147.275, -19.475),
            c(147.325, -19.475),
            c(147.325, -19.525),
            c(147.325, -19.575),
            c(147.275, -19.575),
            c(147.275, -19.625),
            c(147.225, -19.625),
            c(147.175, -19.625),
            c(147.175, -19.675),
            c(147.125, -19.675),
            c(147.075, -19.675),
            c(147.025, -19.675),
            c(147.025, -19.625),
            c(147.025, -19.575),
            c(147.025, -19.525),
            c(147.025, -19.475),
            c(147.075, -19.475),
            c(147.125, -19.475),
            c(147.175, -19.475),
            c(147.225, -19.475),
            c(147.225, -19.525)
          )
        )
      )
    ),
    "center"= c(147.15, -19.55),
    "radiation_params"= c(
      "a"= 0.616505,
      "b"= 0.011761,
      "c"= 2.229468,
      "g"= 0.087302
    )
  ),
  c(
    "region"= "Burdekin",
    "zone"= 2,
    "name"= "Upper Haughton/Clare",
    "zonename"= "green",
    "elevation"= 28,
    "coordinates"= c(
      c(147.15, -19.85),
      c(147.15, -19.80),
      c(147.15, -19.75),
      c(147.15, -19.70),
      c(147.20, -19.90),
      c(147.20, -19.85),
      c(147.20, -19.80),
      c(147.20, -19.75),
      c(147.25, -19.85),
      c(147.25, -19.80),
      c(147.30, -19.80),
      c(147.30, -19.85),
      c(147.15, -19.90),
      c(147.10, -19.90),
      c(147.10, -19.85),
      c(147.10, -19.80),
      c(147.10, -19.75),
      c(147.10, -19.70),
      c(147.05, -19.70),
      c(147.05, -19.75),
      c(147.00, -19.70),
      c(147.25, -19.95),
      c(147.20, -19.95)
    ),
    "geometry"= c(
      "type"= "MultiPolygon",
      "coordinates"= c(
        c(
          c(
            c(147.125, -19.925),
            c(147.075, -19.925),
            c(147.075, -19.875),
            c(147.075, -19.825),
            c(147.075, -19.775),
            c(147.025, -19.775),
            c(147.025, -19.725),
            c(146.975, -19.725),
            c(146.975, -19.675),
            c(147.025, -19.675),
            c(147.075, -19.675),
            c(147.125, -19.675),
            c(147.175, -19.675),
            c(147.175, -19.725),
            c(147.225, -19.725),
            c(147.225, -19.775),
            c(147.275, -19.775),
            c(147.325, -19.775),
            c(147.325, -19.825),
            c(147.325, -19.875),
            c(147.275, -19.875),
            c(147.225, -19.875),
            c(147.225, -19.925),
            c(147.275, -19.925),
            c(147.275, -19.975),
            c(147.225, -19.975),
            c(147.175, -19.975),
            c(147.175, -19.925),
            c(147.125, -19.925)
          )
        )
      )
    ),
    "center"= c(147.15, -19.80),
    "radiation_params"= c(
      "a"= 0.615965,
      "b"= 0.010958,
      "c"= 2.120740,
      "g"= 0.095796
    )
  ),
  c(
    "region"= "Burdekin",
    "zone"= 3,
    "name"= "Millaroo/Dalbeg",
    "zonename"= "grey",
    "elevation"= 76,
    "coordinates"= c(
      c(147.25, -20.10),
      c(147.25, -20.05),
      c(147.25, -20.00),
      c(147.30, -20.25),
      c(147.30, -20.20),
      c(147.30, -20.05),
      c(147.25, -20.15),
      c(147.30, -20.30)
    ),
    "geometry"= c(
      "type"= "MultiPolygon",
      "coordinates"= c(
        c(
          c(
            c(147.325, -20.275),
            c(147.325, -20.325),
            c(147.275, -20.325),
            c(147.275, -20.275),
            c(147.275, -20.225),
            c(147.275, -20.175),
            c(147.325, -20.175),
            c(147.325, -20.225),
            c(147.325, -20.275)
          )
        ),
        c(
          c(
            c(147.275, -20.125),
            c(147.275, -20.175),
            c(147.225, -20.175),
            c(147.225, -20.125),
            c(147.225, -20.075),
            c(147.225, -20.025),
            c(147.225, -19.975),
            c(147.275, -19.975),
            c(147.275, -20.025),
            c(147.325, -20.025),
            c(147.325, -20.075),
            c(147.275, -20.075),
            c(147.275, -20.125)
          )
        )
      )
    ),
    "center"= c(147.25, -20.15),
    "radiation_params"= c(
      "a"= 0.607321,
      "b"= 0.010936,
      "c"= 2.016043,
      "g"= 0.109777
    )
  ),
  c(
    "region"= "Burdekin",
    "zone"= 4,
    "name"= "Home Hill/Mona Park",
    "zonename"= "orange",
    "elevation"= 9,
    "coordinates"= c(
      c(147.20, -19.70),
      c(147.20, -19.65),
      c(147.25, -19.75),
      c(147.25, -19.70),
      c(147.25, -19.65),
      c(147.30, -19.75),
      c(147.30, -19.70),
      c(147.30, -19.65),
      c(147.30, -19.60),
      c(147.35, -19.75),
      c(147.35, -19.70),
      c(147.35, -19.65),
      c(147.40, -19.80),
      c(147.40, -19.75),
      c(147.40, -19.70),
      c(147.40, -19.65),
      c(147.45, -19.75),
      c(147.45, -19.70),
      c(147.45, -19.65),
      c(147.50, -19.80),
      c(147.50, -19.75),
      c(147.50, -19.70),
      c(147.50, -19.65),
      c(147.55, -19.65),
      c(147.35, -19.80),
      c(147.55, -19.70),
      c(147.55, -19.75)
    ),
    "geometry"= c(
      "type"= "MultiPolygon",
      "coordinates"= c(
        c(
          c(
            c(147.525, -19.775),
            c(147.525, -19.825),
            c(147.475, -19.825),
            c(147.475, -19.775),
            c(147.425, -19.775),
            c(147.425, -19.825),
            c(147.375, -19.825),
            c(147.325, -19.825),
            c(147.325, -19.775),
            c(147.275, -19.775),
            c(147.225, -19.775),
            c(147.225, -19.725),
            c(147.175, -19.725),
            c(147.175, -19.675),
            c(147.175, -19.625),
            c(147.225, -19.625),
            c(147.275, -19.625),
            c(147.275, -19.575),
            c(147.325, -19.575),
            c(147.325, -19.625),
            c(147.375, -19.625),
            c(147.425, -19.625),
            c(147.475, -19.625),
            c(147.525, -19.625),
            c(147.575, -19.625),
            c(147.575, -19.675),
            c(147.575, -19.725),
            c(147.575, -19.775),
            c(147.525, -19.775)
            )
        )
      )
    ),
    "center"= c(147.40, -19.70),
    "radiation_params"= c(
      "a"= 0.599392,
      "b"= 0.012197,
      "c"= 2.134340,
      "g"= 0.107501
    )
  ),
  c(
    "region"= "Burdekin",
    "zone"= 5,
    "name"= "Ayr/Brandon",
    "zonename"= "red",
    "elevation"= 8,
    "coordinates"= c(
      c(147.35, -19.60),
      c(147.35, -19.55),
      c(147.35, -19.50),
      c(147.40, -19.60),
      c(147.40, -19.55),
      c(147.40, -19.50),
      c(147.45, -19.60),
      c(147.45, -19.55),
      c(147.45, -19.50),
      c(147.50, -19.60),
      c(147.50, -19.55),
      c(147.50, -19.50),
      c(147.55, -19.60)
    ),
    "geometry"= c(
      "type"= "MultiPolygon",
      "coordinates"= c(
        c(
          c(
            c(147.525, -19.575),
            c(147.575, -19.575),
            c(147.575, -19.625),
            c(147.525, -19.625),
            c(147.475, -19.625),
            c(147.425, -19.625),
            c(147.375, -19.625),
            c(147.325, -19.625),
            c(147.325, -19.575),
            c(147.325, -19.525),
            c(147.325, -19.475),
            c(147.375, -19.475),
            c(147.425, -19.475),
            c(147.475, -19.475),
            c(147.525, -19.475),
            c(147.525, -19.525),
            c(147.525, -19.575)
          )
        )
      )
    ),
    "center"= c(147.45, -19.55),
    "radiation_params"= c(
      "a"= 0.593452,
      "b"= 0.014928,
      "c"= 2.100768,
      "g"= 0.112242
    )
  )
)

locations_geojson= '{
"type":"FeatureCollection",
  "features":[{
    "type":"Feature",
    "region": "Burdekin",
    "zone": 1,
    "name": "Giru/Barratta",
    "zonename": "blue",
    "elevation": 10,
    "geometry": {
      "type": "MultiPolygon",
      "coordinates": [
        [
          [
            [147.225, -19.525],
            [147.275, -19.525],
            [147.275, -19.475],
            [147.325, -19.475],
            [147.325, -19.525],
            [147.325, -19.575],
            [147.275, -19.575],
            [147.275, -19.625],
            [147.225, -19.625],
            [147.175, -19.625],
            [147.175, -19.675],
            [147.125, -19.675],
            [147.075, -19.675],
            [147.025, -19.675],
            [147.025, -19.625],
            [147.025, -19.575],
            [147.025, -19.525],
            [147.025, -19.475],
            [147.075, -19.475],
            [147.125, -19.475],
            [147.175, -19.475],
            [147.225, -19.475],
            [147.225, -19.525]
          ]
        ]
      ]
    },
    "center": [147.15, -19.55],
    "radiation_params": {
      "a": 0.616505,
      "b": 0.011761,
      "c": 2.229468,
      "g": 0.087302
    }
  },{
    "type":"Feature",
    "region": "Burdekin",
    "zone": 2,
    "name": "Upper Haughton/Clare",
    "zonename": "green",
    "elevation": 28,
    "geometry": {
      "type": "MultiPolygon",
      "coordinates": [
        [
          [
            [147.125, -19.925],
            [147.075, -19.925],
            [147.075, -19.875],
            [147.075, -19.825],
            [147.075, -19.775],
            [147.025, -19.775],
            [147.025, -19.725],
            [146.975, -19.725],
            [146.975, -19.675],
            [147.025, -19.675],
            [147.075, -19.675],
            [147.125, -19.675],
            [147.175, -19.675],
            [147.175, -19.725],
            [147.225, -19.725],
            [147.225, -19.775],
            [147.275, -19.775],
            [147.325, -19.775],
            [147.325, -19.825],
            [147.325, -19.875],
            [147.275, -19.875],
            [147.225, -19.875],
            [147.225, -19.925],
            [147.275, -19.925],
            [147.275, -19.975],
            [147.225, -19.975],
            [147.175, -19.975],
            [147.175, -19.925],
            [147.125, -19.925]
          ]
        ]
      ]
    },
    "center": [147.15, -19.80],
    "radiation_params": {
      "a": 0.615965,
      "b": 0.010958,
      "c": 2.120740,
      "g": 0.095796
    }
  },
   {
    "type":"Feature",
    "region": "Burdekin",
    "zone": 3,
    "name": "Millaroo/Dalbeg",
    "zonename": "grey",
    "elevation": 76,
    "geometry": {
      "type": "MultiPolygon",
      "coordinates": [
        [
          [
            [147.325, -20.275],
            [147.325, -20.325],
            [147.275, -20.325],
            [147.275, -20.275],
            [147.275, -20.225],
            [147.275, -20.175],
            [147.325, -20.175],
            [147.325, -20.225],
            [147.325, -20.275]
          ],
          [
            [147.275, -20.125],
            [147.275, -20.175],
            [147.225, -20.175],
            [147.225, -20.125],
            [147.225, -20.075],
            [147.225, -20.025],
            [147.225, -19.975],
            [147.275, -19.975],
            [147.275, -20.025],
            [147.325, -20.025],
            [147.325, -20.075],
            [147.275, -20.075],
            [147.275, -20.125]
          ]
        ]
      ]
    },
    "center": [147.25, -20.15],
    "radiation_params": {
      "a": 0.607321,
      "b": 0.010936,
      "c": 2.016043,
      "g": 0.109777
    }
  },
  {
    "type":"Feature",
    "region": "Burdekin",
    "zone": 4,
    "name": "Home Hill/Mona Park",
    "zonename": "orange",
    "elevation": 9,
    "geometry": {
      "type": "MultiPolygon",
      "coordinates": [
        [
          [
            [147.525, -19.775],
            [147.525, -19.825],
            [147.475, -19.825],
            [147.475, -19.775],
            [147.425, -19.775],
            [147.425, -19.825],
            [147.375, -19.825],
            [147.325, -19.825],
            [147.325, -19.775],
            [147.275, -19.775],
            [147.225, -19.775],
            [147.225, -19.725],
            [147.175, -19.725],
            [147.175, -19.675],
            [147.175, -19.625],
            [147.225, -19.625],
            [147.275, -19.625],
            [147.275, -19.575],
            [147.325, -19.575],
            [147.325, -19.625],
            [147.375, -19.625],
            [147.425, -19.625],
            [147.475, -19.625],
            [147.525, -19.625],
            [147.575, -19.625],
            [147.575, -19.675],
            [147.575, -19.725],
            [147.575, -19.775],
            [147.525, -19.775]
            ]
        ]
      ]
    },
    "center": [147.40, -19.70],
    "radiation_params": {
      "a": 0.599392,
      "b": 0.012197,
      "c": 2.134340,
      "g": 0.107501
    }
  },
  {
    "type":"Feature",
    "region": "Burdekin",
    "zone": 5,
    "name": "Ayr/Brandon",
    "zonename": "red",
    "elevation": 8,
    "geometry": {
      "type": "MultiPolygon",
      "coordinates": [
        [
          [
            [147.525, -19.575],
            [147.575, -19.575],
            [147.575, -19.625],
            [147.525, -19.625],
            [147.475, -19.625],
            [147.425, -19.625],
            [147.375, -19.625],
            [147.325, -19.625],
            [147.325, -19.575],
            [147.325, -19.525],
            [147.325, -19.475],
            [147.375, -19.475],
            [147.425, -19.475],
            [147.475, -19.475],
            [147.525, -19.475],
            [147.525, -19.525],
            [147.525, -19.575]
          ]
        ]
      ]
    },
    "center": [147.45, -19.55],
    "radiation_params": {
      "a": 0.593452,
      "b": 0.014928,
      "c": 2.100768,
      "g": 0.112242
    }
  }
]
}'


monthly_averages = list(
    "1" = list(
        c(
            "datetime"= "2020-01-01",
            "rain"= 242.965,
            "radiation"= 21.3481,
            "maxTemperature"= 32.0486,
            "minTemperature"= 23.8974,
            "minRh"= 58.2006,
            "maxRh"= 91.898,
            "cwu"= 10.7195,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-02-01",
            "rain"= 254.14,
            "radiation"= 20.1614,
            "maxTemperature"= 31.8666,
            "minTemperature"= 23.7877,
            "maxRh"= 59.8361,
            "minRh"= 93.7628,
            "cwu"= 10.2169,
            "wind"= 8.125
        ),
        c(
            "datetime"= "2020-03-01",
            "rain"= 138.3575,
            "radiation"= 19.2367,
            "maxTemperature"= 31.2378,
            "minTemperature"= 22.4751,
            "maxRh"= 57.5756,
            "minRh"= 94.1475,
            "cwu"= 9.6119,
            "wind"= 8.083333
        ),
        c(
            "datetime"= "2020-04-01",
            "rain"= 65.3325,
            "radiation"= 17.6127,
            "maxTemperature"= 29.822,
            "minTemperature"= 20.1817,
            "maxRh"= 54.8326,
            "minRh"= 93.9316,
            "cwu"= 8.5266,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-05-01",
            "rain"= 44.0375,
            "radiation"= 15.4498,
            "maxTemperature"= 27.728,
            "minTemperature"= 17.3004,
            "maxRh"= 52.9123,
            "minRh"= 93.8838,
            "cwu"= 7.0591,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-06-01",
            "rain"= 24.43,
            "radiation"= 14.8439,
            "maxTemperature"= 25.5065,
            "minTemperature"= 14.1649,
            "maxRh"= 49.9428,
            "minRh"= 92.5545,
            "cwu"= 6.0743,
            "wind"= 6.625
        ),
        c(
            "datetime"= "2020-07-01",
            "rain"= 22.63,
            "radiation"= 15.9709,
            "maxTemperature"= 25.2075,
            "minTemperature"= 13.1383,
            "maxRh"= 48.4698,
            "minRh"= 92.7769,
            "cwu"= 6.2005,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-08-01",
            "rain"= 17.4225,
            "radiation"= 18.8604,
            "maxTemperature"= 26.2461,
            "minTemperature"= 14.041,
            "maxRh"= 48.1873,
            "minRh"= 92.9581,
            "cwu"= 7.3849,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-09-01",
            "rain"= 12.2775,
            "radiation"= 22.0858,
            "maxTemperature"= 28.4582,
            "minTemperature"= 16.8122,
            "maxRh"= 48.4633,
            "minRh"= 92.1872,
            "cwu"= 9.2597,
            "wind"=8.041667
        ),
        c(
            "datetime"= "2020-10-01",
            "rain"= 23.8675,
            "radiation"= 23.821,
            "maxTemperature"= 30.0398,
            "minTemperature"= 19.9527,
            "maxRh"= 49.8941,
            "minRh"= 89.2583,
            "cwu"= 10.6674,
            "wind"=9
        ),
        c(
            "datetime"= "2020-11-01",
            "rain"= 53.185,
            "radiation"= 23.827,
            "maxTemperature"= 31.2801,
            "minTemperature"= 22.0556,
            "maxRh"= 51.8878,
            "minRh"= 87.9783,
            "cwu"= 11.26,
            "wind"= 9.166667
        ),
        c(
            "datetime"= "2020-12-01",
            "rain"= 109.5775,
            "radiation"= 23.2365,
            "maxTemperature"= 32.199,
            "minTemperature"= 23.499,
            "maxRh"= 54.5269,
            "minRh"= 89.1951,
            "cwu"= 11.4107,
            "wind"= 8.833333
        )
    ),
    "2" = list(
        c(
            "datetime"= "2020-01-01",
            "rain"= 193.71,
            "radiation"= 21.268,
            "maxTemperature"= 32.7547,
            "minTemperature"= 23.5171,
            "maxRh"= 55.2464,
            "minRh"= 92.4306,
            "cwu"= 10.8166,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-02-01",
            "rain"= 211.505,
            "radiation"= 20.1197,
            "maxTemperature"= 32.4592,
            "minTemperature"= 23.4181,
            "maxRh"= 57.1389,
            "minRh"= 94.2936,
            "cwu"= 10.2971,
            "wind"= 8.125
        ),
        c(
            "datetime"= "2020-03-01",
            "rain"= 103.3175,
            "radiation"= 19.2433,
            "maxTemperature"= 31.761,
            "minTemperature"= 22.009,
            "maxRh"= 55.1127,
            "minRh"= 94.8923,
            "cwu"= 9.678,
            "wind"= 8.083333
        ),
        c(
            "datetime"= "2020-04-01",
            "rain"= 50.37,
            "radiation"= 17.6069,
            "maxTemperature"= 30.2345,
            "minTemperature"= 19.5512,
            "maxRh"= 52.7413,
            "minRh"= 94.9887,
            "cwu"= 8.5365,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-05-01",
            "rain"= 40.9725,
            "radiation"= 15.4403,
            "maxTemperature"= 28.0298,
            "minTemperature"= 16.5374,
            "maxRh"= 51.1009,
            "minRh"= 95.0105,
            "cwu"= 7.0275,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-06-01",
            "rain"= 21.5425,
            "radiation"= 14.8376,
            "maxTemperature"= 25.7453,
            "minTemperature"= 13.2999,
            "maxRh"= 47.9819,
            "minRh"= 93.6578,
            "cwu"= 6.0168,
            "wind"= 6.625
        ),
        c(
            "datetime"= "2020-07-01",
            "rain"= 18.8975,
            "radiation"= 16.0046,
            "maxTemperature"= 25.5426,
            "minTemperature"= 12.2635,
            "maxRh"= 46.2622,
            "minRh"= 93.865,
            "cwu"= 6.1813,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-08-01",
            "rain"= 16.8475,
            "radiation"= 18.9154,
            "maxTemperature"= 26.7737,
            "minTemperature"= 13.2244,
            "maxRh"= 45.5403,
            "minRh"= 93.7836,
            "cwu"= 7.4383,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-09-01",
            "rain"= 7.455,
            "radiation"= 22.122,
            "maxTemperature"= 29.2427,
            "minTemperature"= 16.0599,
            "maxRh"= 45.1368,
            "minRh"= 93.0483,
            "cwu"= 9.3848,
            "wind"=8.041667
        ),
        c(
            "datetime"= "2020-10-01",
            "rain"= 20.235,
            "radiation"= 23.8407,
            "maxTemperature"= 30.986,
            "minTemperature"= 19.3122,
            "maxRh"= 46.0599,
            "minRh"= 90.1624,
            "cwu"= 10.8337,
            "wind"=9
        ),
        c(
            "datetime"= "2020-11-01",
            "rain"= 45.2625,
            "radiation"= 23.8135,
            "maxTemperature"= 32.206,
            "minTemperature"= 21.5364,
            "maxRh"= 48.2658,
            "minRh"= 88.6557,
            "cwu"= 11.4217,
            "wind"= 9.166667
        ),
        c(
            "datetime"= "2020-12-01",
            "rain"= 90.915,
            "radiation"= 23.1307,
            "maxTemperature"= 33.0894,
            "minTemperature"= 23.0525,
            "maxRh"= 51.0371,
            "minRh"= 89.7173,
            "cwu"= 11.5394,
            "wind"= 8.833333
        )
    ),
    "3" = list(
        c(
            "datetime"= "2020-01-01",
            "rain"= 160.5225,
            "radiation"= 21.2652,
            "maxTemperature"= 33.5691,
            "minTemperature"= 23.2309,
            "maxRh"= 51.9644,
            "minRh"= 92.24,
            "cwu"= 10.9947,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-02-01",
            "rain"= 180.5525,
            "radiation"= 20.1401,
            "maxTemperature"= 33.1344,
            "minTemperature"= 23.1102,
            "maxRh"= 54.1878,
            "minRh"= 94.2515,
            "cwu"= 10.4426,
            "wind"= 8.125
        ),
        c(
            "datetime"= "2020-03-01",
            "rain"= 92.505,
            "radiation"= 19.3441,
            "maxTemperature"= 32.3598,
            "minTemperature"= 21.5925,
            "maxRh"= 52.431,
            "minRh"= 95.2636,
            "cwu"= 9.8136,
            "wind"= 8.083333
        ),
        c(
            "datetime"= "2020-04-01",
            "rain"= 48.3925,
            "radiation"= 17.6277,
            "maxTemperature"= 30.6553,
            "minTemperature"= 18.9605,
            "maxRh"= 50.5783,
            "minRh"= 95.5816,
            "cwu"= 8.5801,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-05-01",
            "rain"= 34.85,
            "radiation"= 15.4287,
            "maxTemperature"= 28.2902,
            "minTemperature"= 15.8077,
            "maxRh"= 49.2808,
            "minRh"= 95.755,
            "cwu"= 7.0046,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-06-01",
            "rain"= 22.7075,
            "radiation"= 14.8567,
            "maxTemperature"= 25.9083,
            "minTemperature"= 12.4618,
            "maxRh"= 46.0192,
            "minRh"= 94.4542,
            "cwu"= 5.9702,
            "wind"= 6.625
        ),
        c(
            "datetime"= "2020-07-01",
            "rain"= 17.335,
            "radiation"= 16.0511,
            "maxTemperature"= 25.7963,
            "minTemperature"= 11.4091,
            "maxRh"= 44.2015,
            "minRh"= 94.7873,
            "cwu"= 6.1606,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-08-01",
            "rain"= 14.4375,
            "radiation"= 18.964,
            "maxTemperature"= 27.2326,
            "minTemperature"= 12.434,
            "maxRh"= 42.952,
            "minRh"= 94.2466,
            "cwu"= 7.4968,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-09-01",
            "rain"= 6.345,
            "radiation"= 22.1836,
            "maxTemperature"= 30.0087,
            "minTemperature"= 15.3633,
            "maxRh"= 41.9273,
            "minRh"= 93.4381,
            "cwu"= 9.5457,
            "wind"=8.041667
        ),
        c(
            "datetime"= "2020-10-01",
            "rain"= 23.215,
            "radiation"= 23.8728,
            "maxTemperature"= 31.9641,
            "minTemperature"= 18.7664,
            "maxRh"= 42.3456,
            "minRh"= 90.317,
            "cwu"= 11.0535,
            "wind"=9
        ),
        c(
            "datetime"= "2020-11-01",
            "rain"= 47.9625,
            "radiation"= 23.852,
            "maxTemperature"= 33.1888,
            "minTemperature"= 21.1221,
            "maxRh"= 44.6654,
            "minRh"= 88.5119,
            "cwu"= 11.6573,
            "wind"= 9.166667
        ),
        c(
            "datetime"= "2020-12-01",
            "rain"= 100.3525,
            "radiation"= 23.1558,
            "maxTemperature"= 34.0485,
            "minTemperature"= 22.7247,
            "maxRh"= 47.4442,
            "minRh"= 89.3784,
            "cwu"= 11.7674,
            "wind"= 8.833333
        )
    ),
    "4" = list(
        c(
            "datetime"= "2020-01-01",
            "rain"= 190.75,
            "radiation"= 21.3543,
            "maxTemperature"= 32.1857,
            "minTemperature"= 23.5747,
            "maxRh"= 57.9134,
            "minRh"= 93.3017,
            "cwu"= 10.6808,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-02-01",
            "rain"= 211.81,
            "radiation"= 20.1595,
            "maxTemperature"= 32.0002,
            "minTemperature"= 23.4862,
            "maxRh"= 59.5535,
            "minRh"= 95.032,
            "cwu"= 10.1796,
            "wind"= 8.125
        ),
        c(
            "datetime"= "2020-03-01",
            "rain"= 113.6125,
            "radiation"= 19.2605,
            "maxTemperature"= 31.3161,
            "minTemperature"= 22.1332,
            "maxRh"= 57.6148,
            "minRh"= 95.5486,
            "cwu"= 9.5603,
            "wind"= 8.083333
        ),
        c(
            "datetime"= "2020-04-01",
            "rain"= 49.0825,
            "radiation"= 17.6023,
            "maxTemperature"= 29.834,
            "minTemperature"= 19.7967,
            "maxRh"= 55.2665,
            "minRh"= 95.5837,
            "cwu"= 8.4324,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-05-01",
            "rain"= 38.955,
            "radiation"= 15.4419,
            "maxTemperature"= 27.7229,
            "minTemperature"= 16.882,
            "maxRh"= 53.4527,
            "minRh"= 95.5652,
            "cwu"= 6.9541,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-06-01",
            "rain"= 21.3875,
            "radiation"= 14.8377,
            "maxTemperature"= 25.4999,
            "minTemperature"= 13.6945,
            "maxRh"= 50.4107,
            "minRh"= 94.4985,
            "cwu"= 5.9499,
            "wind"= 6.625
        ),
        c(
            "datetime"= "2020-07-01",
            "rain"= 16.8875,
            "radiation"= 15.9571,
            "maxTemperature"= 25.2418,
            "minTemperature"= 12.6763,
            "maxRh"= 48.641,
            "minRh"= 94.426,
            "cwu"= 6.0968,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-08-01",
            "rain"= 12.575,
            "radiation"= 18.8548,
            "maxTemperature"= 26.2898,
            "minTemperature"= 13.5811,
            "maxRh"= 48.411,
            "minRh"= 94.5125,
            "cwu"= 7.2861,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-09-01",
            "rain"= 8.21,
            "radiation"= 22.0685,
            "maxTemperature"= 28.5678,
            "minTemperature"= 16.3365,
            "maxRh"= 48.4839,
            "minRh"= 93.776,
            "cwu"= 9.1751,
            "wind"=8.041667
        ),
        c(
            "datetime"= "2020-10-01",
            "rain"= 20.7575,
            "radiation"= 23.807,
            "maxTemperature"= 30.1696,
            "minTemperature"= 19.5061,
            "maxRh"= 49.6753,
            "minRh"= 91.2159,
            "cwu"= 10.5877,
            "wind"=9
        ),
        c(
            "datetime"= "2020-11-01",
            "rain"= 42.8075,
            "radiation"= 23.8517,
            "maxTemperature"= 31.4157,
            "minTemperature"= 21.6489,
            "maxRh"= 51.5373,
            "minRh"= 89.8091,
            "cwu"= 11.2055,
            "wind"= 9.166667
        ),
        c(
            "datetime"= "2020-12-01",
            "rain"= 90.2875,
            "radiation"= 23.1983,
            "maxTemperature"= 32.3357,
            "minTemperature"= 23.1056,
            "maxRh"= 54.2179,
            "minRh"= 90.8776,
            "cwu"= 11.3416,
            "wind"= 8.833333
        )
    ),
    "5" = list(
        c(
            "datetime"= "2020-01-01",
            "rain"= 202.4525,
            "radiation"= 21.3775,
            "maxTemperature"= 31.7744,
            "minTemperature"= 23.914,
            "maxRh"= 59.9844,
            "minRh"= 92.7267,
            "cwu"= 10.6342,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-02-01",
            "rain"= 234.225,
            "radiation"= 20.1747,
            "maxTemperature"= 31.6663,
            "minTemperature"= 23.8156,
            "maxRh"= 61.4249,
            "minRh"= 94.5484,
            "cwu"= 10.1469,
            "wind"= 8.125
        ),
       c(
            "datetime"= "2020-03-01",
            "rain"= 133.715,
            "radiation"= 19.2325,
            "maxTemperature"= 31.0268,
            "minTemperature"= 22.5169,
            "maxRh"= 59.4275,
            "minRh"= 95.0561,
            "cwu"= 9.5297,
            "wind"= 8.083333
        ),
        c(
            "datetime"= "2020-04-01",
            "rain"= 56.135,
            "radiation"= 17.5974,
            "maxTemperature"= 29.5697,
            "minTemperature"= 20.2803,
            "maxRh"= 57.0745,
            "minRh"= 95.1105,
            "cwu"= 8.4222,
            "wind"= 8.166667
        ),
        c(
            "datetime"= "2020-05-01",
            "rain"= 41.8675,
            "radiation"= 15.435,
            "maxTemperature"= 27.5323,
            "minTemperature"= 17.4643,
            "maxRh"= 55.1356,
            "minRh"= 95.0748,
            "cwu"= 6.9739,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-06-01",
            "rain"= 21.905,
            "radiation"= 14.8172,
            "maxTemperature"= 25.3428,
            "minTemperature"= 14.3588,
            "maxRh"= 52.2597,
            "minRh"= 94.1642,
            "cwu"= 5.9759,
            "wind"= 6.625
        ),
        c(
            "datetime"= "2020-07-01",
            "rain"= 16.45,
            "radiation"= 15.9316,
            "maxTemperature"= 25.0054,
            "minTemperature"= 13.3701,
            "maxRh"= 50.6847,
            "minRh"= 93.9673,
            "cwu"= 6.1069,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-08-01",
            "rain"= 12.5075,
            "radiation"= 18.8159,
            "maxTemperature"= 25.9066,
            "minTemperature"= 14.2502,
            "maxRh"= 50.8116,
            "minRh"= 94.0894,
            "cwu"= 7.2518,
            "wind"= 7.208333
        ),
        c(
            "datetime"= "2020-09-01",
            "rain"= 9.8925,
            "radiation"= 22.0362,
            "maxTemperature"= 28.0328,
            "minTemperature"= 16.9572,
            "maxRh"= 51.2376,
            "minRh"= 93.1452,
            "cwu"= 9.1051,
            "wind"=8.041667
        ),
        c(
            "datetime"= "2020-10-01",
            "rain"= 24.47,
            "radiation"= 23.7923,
            "maxTemperature"= 29.5239,
            "minTemperature"= 20.0596,
            "maxRh"= 52.7826,
            "minRh"= 90.4655,
            "cwu"= 10.4897,
            "wind"=9
        ),
        c(
            "datetime"= "2020-11-01",
            "rain"= 51.8925,
            "radiation"= 23.8578,
            "maxTemperature"= 30.7873,
            "minTemperature"= 22.1284,
            "maxRh"= 54.3679,
            "minRh"= 89.008,
            "cwu"= 11.1172,
            "wind"= 9.166667
        ),
        c(
            "datetime"= "2020-12-01",
            "rain"= 93.975,
            "radiation"= 23.2336,
            "maxTemperature"= 31.7394,
            "minTemperature"= 23.5233,
            "maxRh"= 56.9475,
            "minRh"= 90.2364,
            "cwu"= 11.2643,
            "wind"= 8.833333
        )
    )
)
```

```{r reading in map data, echo=FALSE, warning=FALSE,message=FALSE}

burdekin_outline=readOGR(paste0(getwd(),"/data/shapefiles/Burdekin_outline.geojson"))

map=leaflet(
    options=leafletOptions(zoomControl=FALSE)
)%>%
    setView(lat=-19.85,lng=147.25,zoom=9.45)%>%
    addTiles()%>%
    addPolygons(
        data = burdekin_outline,
        fillColor = ~zonename,
        col = ~zonename,
        weight=0.5,
        fillOpacity = 0.4
        )%>%
    addLabelOnlyMarkers(
        lat = ~lat,
        lng = ~lon,
        label = ~label,
        data = foreach(
            z=locations,
            .combine=rbind
            )%do%{
                data.frame(
                    "lat"=as.numeric(z[['center2']]),
                    lon=as.numeric(z[['center1']]),
                    label=z[['name']]
                    )
                },
        labelOptions = labelOptions(noHide=TRUE,textOnly = TRUE,direction="right",textsize = "14px",offset = c(0.5,0)) 
        )
```


# 1. Introduction

Increased pressure to reduce pesticide and nutrient run-off from sugarcane farms to the GBR. However, reducing the application of fertilizer can risk reducing crop yield and therefore crop profitability. This is not only an issue for the individual grower but can also affect the long term stability of the industry.An alternative to simply reducing chemical applications such as fertilizer may be to reduce the chance of run-off and deep-drainage by better matching irrigation applications to crop demands. 

Weather forecasts in conjunction with crop growth models, have been used to provide forecasts of upcoming irrigation requirements.  However, in order for forecast crop conditions to be meaningful to growers, the weather forecasts must be of appropriate skill and relevant to the local conditions. Moreover, any information from forecasts must be actionable by a wide range of growers and must be delivered in a timely manner. Previous irrigation forecast and scheduling tools have largely targeted Optimization of irrigation either for improved yield / profit or to manage limited water allocations. Two major limitations of this research are the computational expense of optimization and the limited capacity for growers to apply the recommendations. The first limitation is a result of the need to re-run multiple simulations in order to find an optimum solution. The second limitation is a consequence of the need to be able to apply a specified amount at a specified time reliably. This may be possible for growers with highly automated systems but is impractical for the majority of sugarcane growers. An alternative to optimized forecasts may be to provide forecast probabilities for when or if the next irrigation event is likely to occur. This would be less computationally expensive and would provide more generic and thus more widely applicable risk assessment for sugarcane growers to manage their irrigation schedule. 

# 2. Materials and Methods

In this study we use locally downscaled short range weather forecasts and the APSIM crop model to produce a probability forecast of an irrigation occurring over the next seven days. Weather forecasts are downscaled for five climate zones identified in the sugarcane-growing region around Ayr, Queensland, Australia. Models produce an ensemble of 200 forecasts of rainfall, maximum temperature and minimum temperature. Forecasts are used to produce a probability of irrigation based on a generic Plant-1st ratoon crop in each region. Forecasts are produced daily from 15th August 2019 to 31st May 2021. Forecast skill for rainfall and temperature are compared to 1. Raw forecasts and 2. Naïve forecast approach. All three weather forecasts used the monthly average radiation as input for the APSIM model.

  1. Raw forecast (raw). The raw forecast model use the appropriate ACCESS – G raw model output for each climate zone. These raw forecasts were used as the input to produce the downscaled forecast ensemble.
  2. Naïve forecast (naive). The naïve forecast used the monthly average for temperature and radiation data and assumed no rainfall at all. The Naïve forecast represents a ‘worst case’ forecast and therefore gives a conservative estimate of the next irrigation date. This forecast is used in the IrrigWeb irrigation scheduling tool.
  3. Downscaled forecast (downscaled). The Downscaled forecast used the raw forecasts an input to produce more appropriate forecasts for each zone. These forecasts were generated using a BJP model and produced an ensemble of 200 members that represent the uncertainty in the modelling process.


Classification skill for wet days (>0.1mm rain) and irrigation events are also explored. Rainfall and temperature model skill was assessed using the continuous ranked probability score (CRPS) while classification skill was assessed using ROC AUC, Sensitivity and Specificity. Finally, potential visualization and interpretation methods are discussed for near-real time production. 

## 2.1 Data

### 2.1.1 Climate Zones

The Burdekin sugarcane-growing region was divided into 5 climate zones (Figure 1). These zones were developed in conjunction with BPS extension staff. These zones were considered representative by the Extension staff. The northern zones tended to be wetter with the north-western Giru-Barratta zone being the wettest region and the southern Millaroo-Dalbeg zone being the driest (Figure 2). Weather data were sourced from the SILO data drill gridded database (@RN1). These values are spatially interpolated at a 0.5 by 0.5 decimal degree grid. Climate zones were developed on seasonal data for the period 1970 – 2010. Figure 2 shows the climatological data for that period.


```{r map of zones, fig.cap="Figure 1. Climate zones within the Burdekin sugarcane-growing region. Five zones were identified based on climatology 1. Giru/Barratta (blue), 2. Upper Haughton/Clare (green), 3. Millaroo/Dalbeg (grey), 4. Home Hill/Mona Park (orange), 5. Ayr/Brandon(red)",fig.height=11/2.54,fig.width=8/2.54,echo=FALSE,warning=FALSE,message=FALSE}


# map  # if interactive
knitr::include_graphics('./figures/zones_figure.png')

```

### 2.1.2 Observed weather data

For comparison with weather forecast data the observed data for each zone was taken as the average across all available grid cells in each zone. This process of averaging data was used in developing the downscaled weather forecasts so that comparisons between forecasts and observed data were possible. This suggests that the forecast data were not designed to capture smaller scale a spatial changes. The five climate zones were used  in this analysis as a trade-off between spatial resolution and modelling efficiency. 

```{r get climatology from file and create monthly averages,echo=FALSE,message=FALSE,warning=FALSE}

climate_obs = read.csv("./data/observed_weather.csv")

monthly_average_calculated=climate_obs%>%
  mutate(
    Date = as.Date(datetime,"%Y-%m-%d"),
    month = format(Date,"%m"),
    year = format(Date, "%Y")
    )%>%
    filter(datetime<=as.Date("2010-12-31"))%>%
  group_by(zone,month,year)%>%
  summarize(
    rain=sum(daily_rain),
    rainvar=var(daily_rain),
    maxt=mean(max_temp),
    mint=mean(min_temp),
    radiation=mean(radiation)
    )%>%
  ungroup()%>%
  group_by(zone,month)%>%
  summarize(
    rain=mean(rain),
    rainvar=mean(rainvar),
    tmax=mean(maxt),
    tmin=mean(mint),
    radiation=mean(radiation)
  )%>%
  ungroup()


```


```{r make a plot of monthly climate averages per zone, echo=FALSE,warning=FALSE,message=FALSE}

zoneName = function(l,locs=locations){
  lapply(l,function(m){
    paste(m,". ",locs[[as.numeric(m)]][["name"]],sep="")
})
}


climatology_fig = monthly_average_calculated %>%
  mutate(month =as.Date(sprintf("2022-%s-01",month)))%>%
    ggplot(aes(x=month))+
  geom_bar(
    aes(y=rainvar),
    fill="darkblue",
    stat="identity"
    )+
  scale_x_date(
    date_breaks = "2 months",
    date_labels = "%b"
    )+
  xlab("")+
  geom_line(
    aes(y=tmax*12.5),
    col="red"
    )+
  geom_line(
    aes(y=tmin*12.5),
    col="lightblue"
  )+
  scale_y_continuous(
    limits = c(0,600),
    sec.axis = sec_axis(
      ~./12.5,
      name="Temperature (C)"
      ),
    name="Rainfall (mm)"
  )+
  facet_wrap(
    ~zone,ncol=1,
    strip.position = "top",
    labeller=labeller(zone=zoneName)
    )+
  theme_bw()

tiff(filename="./figures/Figure2.tiff",res=1900,width=8,height=14,units="cm",compression="lzw")
climatology_fig
dev.off()

```

```{r figure 2,fig.cap="Figure 2. Monthly climatology 1970 - 2010 for 5 climate zones in the Burdekin. Monthly total rainfall (green), average daily temperature maximum(red) and minimum(blue) are shown for each region.",fig.height=11/2.54,fig.width=6/2.54,}

knitr::include_graphics("./figures/Figure2.tiff")
```


### 2.1.3 Weather forecasts

ACCESS-G forecasts are generated by the Bureau of Meteorology’s numerical weather prediction (NWP) model (Bureau of Meteorology 2020). These forecasts are highly suitable for statistical post-processing because they are deterministic, numeric time series and are free from human manipulation.
ACCESS-G forecasts have a spatial resolution of 20 km. A forecast is initiated twice a day; first at 00Z (midnight, UTC) and then at 12Z (mid-day, UTC). NWP forecasts usually take several hours to run. Therefore, the 12Z forecasts correspond to forecasts that are available early in the morning in the Burdekin time zone. The model outputs are available at an hourly time-step therefore it is reasonably straightforward to aggregate the hourly forecasts to 24-hour periods that match the Silo observations. No adjustments for daylight savings are necessary.

In order to estimate practical model skill, a leave-x-out cross-validation approach was used. Forecast output used in skill analysis and APSIM simulations were the cross-validation outputs for the period For this study, an archive of ACCESS-G forecasts for the period 15th August 2019 to 23rd November 2021 .


```{r read in raw and downscaled forecasts from files,echo=FALSE,warning=FALSE,message=FALSE}

raw = read.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/access_g_raw_forecasts.csv",header=TRUE)
downscaled = read.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/access_g_pp_forecasts.csv",header=TRUE)
apsim_database = read.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/apsim_database.csv",header=T)
```


## 2.2. Forecast post-processing


The forecast post-processor (PP) is a statistical modelling method for generating ensemble forecasts from deterministic numerical weather prediction outputs. Developed by the Commonwealth Science Innovation and Research Organisation (CSIRO), a variant is used by the Bureau of Meteorology to post-process ACCESS-G catchment rainfall forecasts for ensemble streamflow prediction.  

The centerpiece of the PP is a transformed multivariate normal distribution model, which describes the relationships between NWP forecasts and observations. Log-sinh transformations (Wang et al. 2012) are used to transform NWP and Silo data to conform to the joint normal distribution. The discrete-continuous distribution of rainfall is handled by treating rainfall data as being left-censored at some small threshold defined to be the minimum observable rainfall amount. The parameters of the transformations and multivariate normal model are inferred from historical data using robust Bayesian methods, which are designed to work in a wide range of environments. As a forecasting model, PP generates a forecast distribution for observations, conditional on the known value of the NWP forecast. This reflects the uncertainty in the parameters of the model. PP typically produces very reliable ensemble forecasts that accurately convey forecast uncertainty in ensemble spread. 

A complete mathematical descriptions of an original formulation of PP are given by Robertson et al. (2013) and Shrestha et al. (2015). These studies concern application to Australian catchments. Application to Canadian forecasts is described by Jha et al. (2018). In this investigation, we use a reformulated version of the model that includes an explicit model for the correlation with lead time as well as seasonally-varying parameters. Moreover, we employ a more efficient Gibbs sampling routine.
The RPP is applied to generate forecasts for each climate zone and lead time separately. Therefore, the space–time correlation in the ensemble members will initially be unrealistic across climate zones and across the 7-day forecast horizon. The Schaake shuffle (Clark et al. 2004) is then applied to adjust the space–time correlations in the ensemble, similar to what was observed in the historically observed data. The Schaake shuffle calculates the rank in the observed data and preserves the same rank in the sorted, new ensemble forecast.


## Skill assessment methods

### Continuous Ranked Probability Score (CRPS)

Ensemble forecasts require verification with ensemble forecast verification measures. Here, we use the continuous ranked probability score (CRPS): a metric that combines information about the accuracy and reliability of ensemble forecasts. The (average) CRPS for forecast events   is defined as

$$ CRPS = \frac{1}{T}\sum_{t=1}^{T}\int[F_{t}(y)-H(y-o_{t})]^2dy $$
with $$ H(y-o_{t}) =  \begin{cases}{} 0 \mbox{ if } y<o_t \\ 1 \mbox{ if } y \ge o_{t} \end{cases} $$

Where $y$ is the prediction, $o$ is the observation and $F_{t}(y)$ is the forecast cumulative distribution function (CDF). 

The CRPS is a negatively oriented score such that a CRPS of zero indicates no error (i.e., perfectly accurate forecasts with no ensemble spread). In the case of deterministic forecasts (i.e. where no ensemble of forecasts exists), The CRPS score effectivly reduces to the Mean Absolute Error (MAE) defined as

$$ MAE = \frac{1}/{T}\sum_{t=1}^{T}|{y_{t} - o_{t}|}$$
## Classification verification scores

Forecasts of irrigation events and wet days were treated as classification forecasts. Probabilistic class forecasts were assessed in terms of the Area under the Reciver Operator Characteristic curve (AUC), Sensitivity (Sens), Specificity (Spec) and Balanced Accuracy (BA). AUC, Sens, Spec and BA are positivily orientated scores with a range of 0 – 1 where 1 is the maximum value. 

The ROC AUC can be a less biased measure of classifier performance than the correct classification rate (Bradley 1997, Jin and Ling 2005). A perfect model will have an AUC of one while a non-informative model will have a value of 0.5, while a completely incorrect classification would have a value of zero. Bradley (1997) provide a description of the calculation of the AUC score.
Accuracy (correct classification) may be a poor skill measure for uneven classes. For example there are more dry days than wet days and many more days where irrigation is not required than irrigation events. In these cases a model will have a high accuracy simply by correctly guessing dry/no irrigation every day. Similarly, the AUC alone does not provide detailed information on error types when classes are imbalanced. In these cases looking at the Sensitivity (correct classification of the positive events e.g. wet /irrigation events) and Specificity (correct classification of the negative events, e.g. dry days / non-irrigation days). In cases of imbalanced classes it can help to consider the balanced accuracy calculated as
$$ BA = \frac{(Sens+Spec)}{2} $$
Where:
$$ Sens = \frac{TP}{(TP+FN)} $$

$$ Spec = frac{TN}{(TN+FP)} $$
And TP is the number of true positives; TN is the number of True negatives; FP is the number of false positives and FN is the number of false negatives. From equations 3 and 4 it can be seen that a high sensitivity is related to a low incidence of false negatives. For example, a model with high sensitivity will rarely forecast a dry day when it will actually be wet or suggest no irrigation when an irrigation event will be needed). Conversly, a model with high Specificity will have a low false positive rate (e.g. a model with high specificity will rarely forecast a wet day when it will actually be dry or suggest an irrigation when no irrigation is needed.

In assessing the forecasts of wet days (rain > 0.2 mm) and irrigation events, the AUC, Sensitivity, Specificity and Balanced Accuray were investigated. For forecasts of daily rainfall, maximum and miniumum temperatures the CRPS was investigated. 


## APSIM modelling

For each zone a plant – 1st ratoon cropping cycle was simulated using APSIM. The crop was first planted on August 15th 2019 with a simulation end date of 23rd November 2021. This represents a late planted, 15 month plant crop followed by a 12 month first ratoon. In order to reduce the effects of stress on the crop, the cycle was fertilized with 500kg/ha of urea fertilizer one month after sowing/ratooning. For all climate zones a single soil was used. The soil was characterised as a silty loam and had a plant available water content of 162 mm.

 An automated irrigation cycle was implemented that refilled the profile whenever the soil water deficit (SWD) dropped below -60 mm. A 40 mm/ha irrigation was also applied at planting and ratooning in order to ensure the water profile was full and the crop did not fail to grow. These irrigation events were not considered in the final analysis. Irrigation was stopped 60 days prior to harvesting in order to allow the crop to dry down before harvest. This dry down is often used in the region to increase sugar yields. Dry down periods were not included in the final analysis of irrigation events.

While the automatic irrigation schedule may not represent practices within the region, its use in simulation ensured that there was a set rule for irrigating. In total this resulted in 21 – 30 irrigation events throughout the crop cycle depending on the zone. Figure 4 shows the ‘observed’ APSIM simulated growth, rainfall and irrigation events. It can be seen in Figure 3 that the drier regions such as Upper Haughton/Clare and Millaroo/Dalbeg were more affected by the dry-off period in the plant ratoon, with Biomass accumulation stalling before harvest. It can also be seen that the irrigation by SWD occasionally resulted in an irrigation event immediately followed by rainfall.

The APSIM model requires rainfall, maximum and minimum temperature and radiation data at a daily time step. For the ‘observed’ run of the simulations, observed radiation data was calculated in the same manner as temperature data. For forecast runs, all forecasts used the monthly mean radiation data as radiation data were not directly forecast. This means that variation between forecast models is driven by the variation in rainfall and temperature data.


```{r create a plot of crop growth, echo=F,warning=FALSE,message=FALSE}


apsim_fig=apsim_database%>%
    filter(model=="obs")%>%
  mutate(
    Date = as.Date(Date,"%d/%m/%Y")
    )%>%
  left_join(
    climate_obs%>%
        group_by(zone)%>%
      mutate(
        Date=as.Date(datetime),
        daily_rain = lead(daily_rain,1)
        )%>%
        ungroup(),
    by=c(
      "zonenumber"="zone",
      "Date"="Date"
      )
    )%>%
  ggplot(aes(x=Date))+
  geom_bar(aes(y=irrigation),stat="identity",col="lightblue")+
  geom_bar(aes(y=daily_rain),stat="identity",col="darkblue")+
  facet_wrap(~zonenumber,
             strip.position ="top",
             ncol=1,
    labeller=labeller(zonenumber=zoneName)
    )+
  geom_line(aes(y=biomass/100*4.615385))+
  scale_y_continuous(
    limits=c(0,300),
    sec.axis = sec_axis(~./4.615385,name="Yield (t/ha)"),
    name="Rainfall/Irrigation (mm)"
    )+
  theme_bw()

tiff(filename="./figures/Figure4.tiff",res=1900,width=12,height=16,units="cm",compression="lzw")
apsim_fig
dev.off()

```

```{r Figure 3,fig.cap="Figure 4. Simulated crop growth for generic plant-1st ratoon cycle for each region. Biomass yields (black line), rainfall events (green) and irrigation events (blue) are shown for each zone." ,fig.height=11/2.54,fig.width=6/2.54,echo=FALSE,message=FALSE}

knitr::include_graphics("./figures/Figure4.tiff")

```


# Results and Discussion

## Rainfall Forecasts

```{r calculate rainfall forecast skill,message=FALSE,echo=F,warning=F}

r2 = function(obs,pred){
  obs_bar = mean(obs)
  rss = sum((obs-pred)^2)
  tss = sum((obs-obs_bar)^2)
  rSquared = 1 - (rss/tss)
  return(rSquared)
}

crps_ecdf = function(f_ens, o){
  f_ens = f_ens[order(f_ens,decreasing = F)]
  o_cdf = f_cdf = f_prev = crps = 0
  m = length(f_ens)
  for(i in 1:m){
    f_n = f_ens[i]
    if(o_cdf == 0 & o < f_n){
      crps = crps + ((o - f_prev) * f_cdf^2)
      crps = crps + ((f_n - o) * (f_cdf - 1)^2)
      o_cdf = 1
    }
    else {
      crps = crps + ((f_n - f_prev) * (f_cdf - o_cdf)^2)
    }
    f_cdf = i/m
    f_prev = f_n
  }
  # obs to the right of the forecast.
  if(o_cdf == 0){
    crps = crps + (o - f_n)
  }
  return(crps)
}

dates = unique(raw%>%
  mutate(
    time_step_ahead = time_step_ahead-1, 
    datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"),
    precip = round(precip,1),
    )%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
  left_join(
      climate_obs%>%
          group_by(zone)%>%
          mutate(
              datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
              daily_rain = lead(daily_rain,1)
              )%>%
          ungroup(),
      by=c("datetime"="datetime","zone"="zone"))%>%
  filter(is.na(daily_rain)==F)%>%select(datetime))%>%
  pull()

skill_raw = raw%>%
  mutate(
    time_step_ahead = time_step_ahead-1, 
    datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"),
    precip = round(precip,1),
    )%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  left_join(climate_obs%>%
          group_by(zone)%>%
          mutate(
              datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
              daily_rain = lead(daily_rain,1)
              )%>%
          ungroup(),
      by=c("datetime"="datetime","zone"="zone"))%>%
  filter(is.na(daily_rain)==F)%>%
  rowwise()%>%
  mutate(
    crps=crps_ecdf(precip,daily_rain),
    error = precip-daily_rain,
    )%>%
  ungroup()%>%
  group_by(zone,time_step_ahead)%>%
  summarize(
    rSquared = r2(daily_rain,precip),
    mae = mean(abs(daily_rain - precip)),
    me = mean(error),
    crps = mean(crps),
    crps_sd = sd(crps),
    corr = cor(daily_rain,precip)
  )

skill_downscaled = downscaled%>%
  mutate(
    precip = round(precip,1),
    time_step_ahead = time_step_ahead-1,
    datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"))%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  left_join(
    climate_obs%>%
          group_by(zone)%>%
          mutate(
              datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
              daily_rain = lead(daily_rain,1)
              )%>%
          ungroup(),
    by=c("datetime"="datetime","zone"="zone")
    )%>%
  mutate(error=precip-daily_rain)%>%
  filter(is.na(daily_rain)==F)%>%
  group_by(zone,datetime,time_step_ahead)%>%
  summarize(
    crps = crps_ecdf(precip,median(daily_rain)),
    daily_rain = median(daily_rain),
    mean_precip = mean(precip),
    mean_error =mean(error),
  )%>%
  ungroup()%>%
  group_by(zone,time_step_ahead)%>%
  summarize(
    rSquared = r2(daily_rain,mean_precip),
    mae = mean(abs(daily_rain - mean_precip)),
    me = mean(mean_error),
    crps = mean(crps),
    crps_sd = sd(crps),
    corr = cor(mean_precip,daily_rain),
  )


skill_naive = climate_obs%>%
    group_by(zone)%>%
    mutate(
        datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
        daily_rain = lead(daily_rain,1),
        )%>%
    ungroup()%>%
  mutate(
    no_rain=0
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  rowwise()%>%
  mutate(
    crps=crps_ecdf(no_rain,daily_rain),
    error=no_rain-daily_rain,
    )%>%
  filter(datetime %in% dates)%>%
  ungroup()%>%
  group_by(zone)%>%
  summarize(
    rSquared = r2(no_rain,daily_rain),
    mae = mean(abs(daily_rain - no_rain)),
    me = mean(error),
    crps = mean(crps),
    crps_sd = sd(crps),
    corr = cor(daily_rain,no_rain)
  )

rain_skill_out=skill_downscaled%>%
  select(zone,time_step_ahead,crps,corr,me,mae)%>%
  mutate('model'="downscaled")%>%
  bind_rows(
    skill_raw%>%
      select(zone,time_step_ahead,crps,corr,me,mae)%>%
      mutate('model'="raw")
    )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 0)
  )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 1)
  )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 2)
  )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 3)
  )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 4)
  )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 5)
  )%>%
  bind_rows(
    skill_naive%>%
      select(zone,crps,corr,me,mae)%>%
      mutate('model'="naive",time_step_ahead = 6)
  )
```


 
Figure 5 shows the cumulative ranked probability scores (CRPS) for naive, raw and the downscaled daily forecasts for rainfall. For single member forecasts (naive and raw), the CRPS is equivalent to the mean absolute error (MAE). In all zones, the downscaled forecasts show lower CRPS values at all lead times compared to the naïve and raw forecasts. For all zones except the Millaroo/Dalbeg zone the raw forecast outperformed the naïve forecast until a lead time of 3 or 4 days. The raw forecast of the Millaroo zone had a higher CRPS score than simply using the monthly average (naive model). This zone was the driest zone. The raw forecast tends to over predict daily rainfall in general which may have contributed to the particularly low performance of the raw forecast in the Millaroo/Dalbeg zone.


```{r make plot crps rainfall,echo=F,message=F,warning=F}

rainfall_CRPS = rain_skill_out%>%
  ggplot(aes(x=time_step_ahead,y=crps,fill=model))+
    scale_color_brewer(type="qual",palette=1)+
  geom_bar(stat="identity",position="dodge")+
  facet_wrap(
    ~zone,
    scales="free_y",
    ncol = 1,
    labeller=labeller(zone=zoneName)
    )+
  theme_bw()+
  xlab("lead time (days)")+
    ylab("Daily Rainfall CRPS")

tiff(filename="Figure5.tiff",res=1900,width=10,height=13,units="cm",compression="lzw")
rainfall_CRPS
dev.off()
```


```{r plot rainfall CRPS skill, echo=FALSE, message=FALSE,fig.height=7,fig.width=5,fig.cap="Figure 5. CRPS by lead time for rainfall forecasts of three forecast models. Lines represent CRPS scores for naive (red), downscaled (green) and raw (blue) forecast models"}

knitr::include_graphics("./figures/Figure5.tiff")

```

The results from  Figure 5 show that the downscaling method applied to the forecast was able to improve the predictive performance of the raw forecasts. CRPS scores tended to be lower in drier zones for all models. For example, the naïve model scores were below 2 for the Upper Haughton/Clare, Home/Hill Mona Park, Millaroo/Dalbeg zones but above 2 for Giru/Baratta and above 3 for the Ayr/Brandon zone. 

Higher rainfall likely means more wet days which are more difficult to predict than dry days. This may explain the lower CRPS scores for drier zones. The results suggest that the Raw forecasts may be reasonable for a 5 day (leadtime 0 - 4) forecast but errors tend to creep in at later lead times. Downscaling the forecast has improved the forecasts overall but particularly at later lead times. These results will help give confidence in the use of the forecasts for advance scheduling of irrigation events as well as other farm management decisions that are affected by rainfall. 


## Temperature forecasts

Figure 6 shows the CRPS values for maximum temperature while Figure 7 shows the CRPS values for minimum temperature. For all zones except the Ayr/Brandon zone, both raw and downscaled forecasts outperformed the naïve forecast at all lead times for both maximum and minimum temperatures. The raw forecast had a higher CRPS value than the monthly average at lead times greater than two and four days respectively for maximum and minimum temperature forecasts. Downscaled forecasts always had a lower CRPS score than the naïve or raw forecast models. The results from Figures 6 and 7 suggest that the downscaing the forecasts has improved on the raw temperature forecasts.


```{r claculate max temp forecast skill,message=FALSE,echo=F,warning=F}

skill_raw = raw %>%
    mutate(
        time_step_ahead = time_step_ahead-1,
        datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d")
    )%>%
    mutate(
        zone = ifelse(
            zone=="blue",1,ifelse(
                zone=="green",2,ifelse(
                    zone=="grey",3,ifelse(
                        zone=="orange",4,5)
                    )
                )
            )
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
    left_join(
        climate_obs %>%
            mutate(datetime = format(as.Date(datetime,"%Y-%m-%d")),"%Y-%m-%d"),
        by=c("datetime","zone")
        )%>%
    filter(is.na(tmax)==F & is.na(max_temp)==F)%>%
    rowwise()%>%
    mutate(crps=crps_ecdf(tmax,max_temp))%>%
    ungroup()%>%
    group_by(zone,time_step_ahead)%>%
    summarize(
      rSquared = r2(tmax,max_temp),
      mae = mean(abs(max_temp - tmax)),
      crps = mean(crps),
      corr = cor(max_temp,tmax)
   )

skill_downscaled = downscaled%>%
  mutate(
      time_step_ahead = time_step_ahead-1,
      datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"))%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  left_join(
    climate_obs%>%
      mutate(datetime = format(as.Date(datetime,"%Y-%m-%d")),"%Y-%m-%d"),
    by=c("datetime","zone")
    )%>%
  filter(is.na(tmax)==F & is.na(max_temp)==F)%>%
  group_by(zone,datetime,time_step_ahead)%>%
  summarize(
    max_temp = mean(max_temp),
    tmax = mean(tmax),
    crps = crps_ecdf(tmax,mean(max_temp))
  )%>%
  ungroup()%>%
  group_by(zone,time_step_ahead)%>%
  summarize(
    rSquared = r2(max_temp,tmax),
    mae = mean(abs(max_temp - tmax)),
    crps = mean(crps)
  )

skill_naive = climate_obs%>%
  mutate(
    datetime = as.Date(datetime,"%Y-%m-%d"),
    month = as.numeric(format(datetime,"%m"))
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  filter(is.na(max_temp)==F)%>%
    left_join(
        monthly_average_calculated%>%
            mutate(month=as.numeric(month))%>%
            select(zone,month,tmax),
        by=c("zone","month")
    )%>%
  rowwise()%>%
  mutate(crps=crps_ecdf(tmax,max_temp))%>%
  ungroup()%>%
  group_by(zone)%>%
  summarize(
    rSquared = r2(tmax,max_temp),
    mae = mean(abs(max_temp - tmax)),
    crps = mean(crps),
    corr = cor(max_temp,tmax)
  )

tmax_skill_out = skill_downscaled%>%
  select(zone,time_step_ahead,crps)%>%
  mutate('model'="downscaled")%>%
  bind_rows(
    skill_raw%>%
      select(zone,time_step_ahead,crps)%>%
      mutate('model'="raw"),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 0),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 1),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 2),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 3),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 4),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 5),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 6)
    )
```

```{r create plot tmax crps, fig.height=5,fig.width=4,echo=F,message=F,warning=F,fig.height=7,fig.width=5,fig.cap="Figure 6. CRPS by lead time for maximum temperature forecasts of three forecast models. Lines represent CRPS scores for naive (red), downscaled (green) and raw (blue) forecast models"}

tmax_CRPS = tmax_skill_out%>%
  ggplot(aes(x=time_step_ahead,y=crps,col=model))+
    scale_color_brewer(type="qual",palette=1)+
  geom_bar(stat="identity",position="dodge")+
  facet_wrap(
    ~zone,
    scales="free_y",
    ncol = 1,
    labeller=labeller(zone=zoneName)
    )+
  theme_bw()+
  xlab("lead time (days)")+
  ylab("Maximum Temperatured CRPS")


tiff(filename="Figure6.tiff",res=1900,width=10,height=13,units="cm",compression="lzw")
tmax_CRPS
dev.off()

tmax_CRPS
```

Interestingly, the difference between raw and downscaled models was greater for the maximum temperature forecasts than for the minimum temperature forecasts. Overall the CRPS scores fore maximum temperature tended to be higher than those for the minimum temperature forecasts. This suggests that the minimum temperatures were more difficult to predict and possibly more variable than maximum temperatures.

```{r plotting min temp forecast skill,message=FALSE,echo=F,warning=F}

skill_raw = raw%>%
  mutate(
      time_step_ahead = time_step_ahead - 1, 
      datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"))%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  left_join(
      climate_obs%>%
          group_by(zone)%>%
          mutate(
              datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
          min_temp = lead(min_temp,1)
      )%>%ungroup(),
      by=c("datetime"="datetime","zone"="zone")
)%>%
  filter(is.na(tmin)==F & is.na(min_temp)==F)%>%
  rowwise()%>%
  mutate(crps=crps_ecdf(tmin,min_temp))%>%
  ungroup()%>%
  group_by(zone,time_step_ahead)%>%
  summarize(
    rSquared = r2(tmin,min_temp),
    mae = mean(abs(min_temp - tmin)),
    crps = mean(crps),
    corr = cor(min_temp,tmin)
  )

skill_downscaled = downscaled%>%
  mutate(
      time_step_ahead = time_step_ahead - 1,
      datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d")
      )%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
    filter(datetime > as.Date("2019-08-14"),datetime < as.Date("2021-11-24"))%>%
  left_join(
    climate_obs%>%
        group_by(zone)%>%
      mutate(
          datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
          min_temp = lead(min_temp,1)
      )%>%ungroup(),
    by=c("datetime"="datetime","zone"="zone")
    )%>%
  filter(is.na(tmin)==F & is.na(min_temp)==F)%>%
  group_by(zone,datetime,time_step_ahead)%>%
  summarize(
    min_temp = mean(min_temp),
    tmin = mean(tmin),
    crps = crps_ecdf(tmin,mean(min_temp))
  )%>%
  ungroup()%>%
  group_by(zone,time_step_ahead)%>%
  summarize(
    rSquared = r2(min_temp,tmin),
    mae = mean(abs(min_temp - tmin)),
    crps = mean(crps)
  )

skill_naive = climate_obs%>%
    group_by(zone)%>%
  mutate(
    datetime = as.Date(datetime,"%Y-%m-%d"),
    month = as.numeric(format(datetime,"%m")),
    min_temp = lead(min_temp,1)
    )%>%
    ungroup()%>%
  filter(datetime %in% as.Date(dates),is.na(min_temp)==F)%>%
    left_join(
        monthly_average_calculated%>%
            mutate(month=as.numeric(month))%>%
            select(zone,month,tmin),
        by=c("zone","month")
    )%>%
  rowwise()%>%
  mutate(crps=crps_ecdf(tmin,min_temp))%>%
  ungroup()%>%
  group_by(zone)%>%
  summarize(
    rSquared = r2(tmin,min_temp),
    mae = mean(abs(min_temp - tmin)),
    crps = mean(crps),
    corr = cor(min_temp,tmin)
  )

tmin_skill_out = skill_downscaled%>%
  select(zone,time_step_ahead,crps)%>%
  mutate('model'="downscaled")%>%
  bind_rows(
    skill_raw%>%
      select(zone,time_step_ahead,crps)%>%
      mutate('model'="raw"),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 0),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 1),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 2),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 3),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 4),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 5),
    skill_naive%>%
      select(zone,crps,corr)%>%
      mutate('model'="naive",time_step_ahead = 6)
    )

```

```{r plot tmin crps, fig.height=5,fig.width=4,echo=F,message=F,warning=F,fig.height=7,fig.width=5,fig.cap="Figure 7. CRPS by lead time for minimum temperature forecasts of three forecast models. Lines represent CRPS scores for naive (red), downscaled (green) and raw (blue) forecast models"}


tmin_CRPS = tmin_skill_out%>%
  ggplot(aes(x=time_step_ahead,y=crps,col=model))+
    scale_color_brewer(type="qual",palette=1)+
  geom_bar(stat="identity",position="dodge")+
  facet_wrap(
    ~zone,
    scales="free_y",
    ncol = 1,
    strip.position = "top",
    labeller=labeller(zone=zoneName)
    )+
  theme_bw()+
  xlab("lead time (days)")+
  ylab("Minimum Temperature CRPS")
  
tiff(filename="Figure7.tiff",res=1900,width=10,height=13,units="cm",compression="lzw")
tmin_CRPS
dev.off()

tmin_CRPS

```


In terms of crop water requirements and therefore irrigation needs, the effect of daily temperature variability over the course of 1 week is unlikely to have a large impact compared to rainfall. However, the cumulative effects over longer forecast periods could have a larger impact. 

## Rainfall events forecast

ROC AUC scores suggested that both the downscaled and raw models were able to outperform a naive model at classifying a day as wet (>0.2 mm rain) (Figure 8). The naive model had an AUC score of 0.5, a sensitivity of 0 (i.e. cannot predict a wet day) and a specificity of 1 (all dry days are predicted to be dry). The downscaled model had higher ROC scores than the raw model for all zones. However, the balanced accuracy (BA) was either similar or lower than the raw model. This is because the downscaled model had high specificity (lower false positives) but low sensitivity (higher false negative) when compared to the raw forecast results. 

The ACCESS-G raw forecasts tend to predict some rainfall on most days. This is known as the ‘drizzel effect’ and may be the reason raw forecasts tend to have a higher Sensitivity. I.E. the raw forecast is more likely to have some rainfall on wet days increasing the Sensitivity but also on dry days, reducing the Specificity. Conversly, the downscaled forecast attempts to correct the raw forecast to match observed conditions. This results in fewer forecast days with rainfall which would result in the observed higher Specificity. The lower Sensitivity is likely due to an overcorrection. The downscaled model is predicting wet days to be dry as well as dry days. This effect seems to be more pronounced in the drier Millaroo/Dalbeg zone, where at longer lead times the Sensitivity of the downscaled model approaches zero and the Specificity approaches 1. This is similar to the naive model which assumes no rainfall. 

The downscaled model produce as probability of a day being wet (i.e. x-out-of-200 models). The Sensitivy and Specificity in Figure 8 are representative of a ‘cut-off’ probability of 50%. i.e. whichever class has the highest probability is assumed to be the forecast class. As the downscaled model forecasts of wet days appears to be overly conservative (i.e. low sensitivity), especially in drier zones, users may need to be less cautious with forecast wet days. For example, a day may be considered ‘wet’ if the forecast probabilty is above 30% rather than above 50%. However, the choice of a cut-off point would be dependent on the goal of the study or the risk profile of the farmer. Future research could consider the impact of this choice on management decisions.


```{r rainfall roc scores,message=F,warning=F,echo=F}

set = expand.grid(
  zone=c(1,2,3,4,5),
  tstep=c(0,1,2,3,4,5,6),
  ramount=c(0.1,0.2,5,10,20,50),
  model=c("raw","downscaled")
)

rain_factor = foreach(
  ramount=c(0.1,0.2,5,10,20,50),
  .combine="rbind"
  )%do%{
  raw%>%
    mutate(
      time_step_ahead = time_step_ahead,
      datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"))%>%
    mutate(
      zone = ifelse(
        zone=="blue",1,ifelse(
          zone=="green",2,ifelse(
            zone=="grey",3,ifelse(
              zone=="orange",4,5)
            )
          )
        )
      )%>%
    left_join(
        climate_obs%>%
            group_by(zone)%>%
        mutate(
            datetime = format(as.Date(datetime,"%Y-%m-%d")),"%Y-%m-%d",
            daily_rain = lead(daily_rain,1)
            )%>%
        ungroup(),
        by=c("datetime"="datetime","zone"="zone"))%>%
    filter(is.na(daily_rain)==F)%>%
  filter(datetime %in% dates,is.na(min_temp)==F)%>%
    mutate(
      obs_rain_flag = ifelse(daily_rain>ramount,"wet","dry"),
      pred_rain_flag = ifelse(precip>ramount,"wet","dry"),
      )%>%
    group_by(zone,datetime,time_step_ahead)%>%
    summarize(
      obs = obs_rain_flag[1],
      wet = sum(ifelse(pred_rain_flag == "wet",1,0))/length(pred_rain_flag),
      dry = sum(ifelse(pred_rain_flag == "dry",1,0))/length(pred_rain_flag)
    )%>%
    ungroup%>%
    rowwise()%>%
    mutate(
      pred = factor(ifelse(wet>dry,"wet","dry"),levels=c("wet","dry")),
      obs = factor(obs,levels=c("wet","dry"))
      )%>%
    ungroup()%>%
    mutate(
      ramount=ramount,
      model="raw"
    )%>%
      bind_rows(
        downscaled%>%
          mutate(
            precip = round(precip,1),
            time_step_ahead = time_step_ahead,
            datetime = format(as.Date(as.character(date),"%Y%m%d") + time_step_ahead,"%Y-%m-%d"))%>%
          mutate(
            zone = ifelse(
              zone=="blue",1,ifelse(
                zone=="green",2,ifelse(
                  zone=="grey",3,ifelse(
                    zone=="orange",4,5)
                  )
                )
              )
            )%>%
          left_join(
            climate_obs%>%
              group_by(zone)%>%
              mutate(
                  datetime = format(as.Date(datetime,"%Y-%m-%d"),"%Y-%m-%d"),
                  daily_rain = lead(daily_rain,1)
                  )%>%
                ungroup(),
            by=c("datetime"="datetime","zone"="zone")
            )%>%
          filter(is.na(daily_rain)==F)%>%
  filter(datetime %in% dates,is.na(min_temp)==F)%>%
          mutate(
            obs_rain_flag = ifelse(daily_rain>ramount,"wet","dry"),
            pred_rain_flag = ifelse(precip>ramount,"wet","dry")
            )%>%
          group_by(zone,datetime,time_step_ahead)%>%
          summarize(
            obs = obs_rain_flag[1],
            wet = sum(ifelse(pred_rain_flag == "wet",1,0))/length(pred_rain_flag),
            dry = sum(ifelse(pred_rain_flag == "dry",1,0))/length(pred_rain_flag)
            )%>%
          ungroup()%>%
          rowwise()%>%
          mutate(
            pred = factor(ifelse(wet>dry,"wet","dry"),levels=c("wet","dry")),
            obs = factor(obs,levels=c("wet","dry")),
            )%>%
          ungroup()%>%
          mutate(
            ramount=ramount,
            model="downscaled"
          )
      )
    }

class_out = foreach(
  z = set$zone,
  t = set$tstep,
  r = set$ramount,
  m = set$model,
  .combine="rbind"
  )%do%{
    xx = caret::twoClassSummary(
      as.data.frame(
        rain_factor
        )%>%
        filter(
          zone==z,
          time_step_ahead==t,
          ramount==r,
          model==m
          ),
      lev=c("wet","dry")
      )
    data.frame(
      "zone"=z,
      "time_step_ahead"=t,
      "ramount"=r,
      "model"=m,
      "AUC"=xx[["ROC"]],
      "Sens"=xx[["Sens"]],
      "Spec"=xx[["Spec"]],
      "BA"= (xx[["Sens"]]+xx[["Spec"]])/2
      )
  }


class_out_roc_curve = foreach(
  z = set$zone,
  t = set$tstep,
  r = set$ramount,
  m = set$model,
  .combine="rbind"
  )%do%{
    xx = pROC::roc(
      obs~wet,
      rain_factor%>%
        filter(
          zone==z,
          time_step_ahead==t,
          ramount==r,
          model==m
          )%>%
      mutate(obs=factor(obs,ordered=T,levels=c("dry","wet")))
    )
    data.frame(
      "zone"=z,
      "time_step_ahead"=t,
      "ramount"=r,
      "model"=m,
      "Sens"=xx$sensitivities,
      "Spec"=xx$specificities,
      "BA"= (xx$sensitivities+xx$specificities)/2,
      "Thres"=xx$thresholds
      )
  }
```

```{r plot skill by leadtime, fig.cap="Figure 8. Classification Skill for rainfall>0.2 mm. Figure shows AUC, balanced accuracy, Sensitivity and Specificity by lead time for each zone Giru/Barratta () Upper Haugton/Clare (), Millarooo/Dalbeg (), Home Hill/Mona Park(), Ayr/Brandon() for bo the raw (solid) and downscaled (dashed) models.",fig.height=22/1.5/2.54,fig.width=22/2.54,echo=FALSE,warning=FALSE,message=FALSE}

rain_class_skill = class_out%>%
  filter(ramount==0.2)%>%
  mutate(model=ifelse(model=="pp","downscaled","raw"))%>%
  mutate(model=factor(model,levels=c("downscaled","raw"),labels=c("downscaled","raw")))%>%
  pivot_longer(names_to="measure",cols=c(AUC,Sens,Spec,BA))%>%
    ggplot(
        aes(
            x=time_step_ahead,
            y=value,
            col=model)
        )+
    scale_color_manual(values=c("downscaled"='#66c2a5',"raw"='#fc8d62'))+
    #facet_grid(rows=vars(measure),scales="free_y")+
    facet_grid(cols=vars(zone),rows=vars(measure),
      labeller=labeller(zone=zoneName))+
    geom_bar(stat="identity",position="dodge")+
    theme_bw()+
    xlab("lead time (days)")+
    ylab("Wet day skill score")


tiff(filename="Figure8.tiff",height=22/1.5,width=24,res=1900,units="cm",compression="lzw")
rain_class_skill
dev.off()

rain_class_skill
```

<!-- Figure 9 shows the ROC curves for downscaled and raw wet day classifications. Results suggest that a similar level of sensitivity to the raw model could be achieved using a cut-off of 0.3 (30% chance of wet day = wet day prediction. A cut-off of 0.4 results in a slightly higher balanced accuracy than the raw models (CHECK). These probabilistic forecast means that growers can use their own risk assessment to choose at what point they are willing to assume a rainfall event is ‘likely’. As a suggestion for a balanced forecast (similar skill at predicting wet or dry days) a cut-off of 0.3 – 0.4 is recommended. In order to reduce the risk of false positives (assuming wet days when no rain occurs) a cut-off of >-0.5 is suitable although this will increase the risk of false negatives (assuming dry when rain occurs).These recommendations can be made for higher rainfall cut-offs (SUdownscaledLEMENTARY DATA). -->


```{r plot roc curve for wet days, fig.cap="Figure 9. ROC curves for rainfall>0.2 mm in the Giru/Barratta region. Grey dashed line represents naive classifier, Black dashed line represents the downscaled forecast model ) while the solid line represents the raw forecasts. The 'hinge' of the raw forecast is equivalent to the 0.5 threshold for the raw model. Rows represent lead times. ",fig.height=22/2.54,fig.width=28/3/2.54,echo=FALSE,warning=FALSE,message=FALSE,eval=FALSE}


rain_roc_curve=class_out_roc_curve%>%
  filter(ramount==0.2,zone==1)%>%
  ggplot(
      aes(
          x=Spec,
          y=Sens,
          #col=factor(
          #    zone,
          #    levels=c(1,2,3,4,5),
          #    labels=c("Giru/Barratta","UpperHauton/Clare","Millaroo/Dalbeg","HomeHill/MonaPark","Ayr/Brandon")
          #        ),
          linetype=model
          ))+
    facet_wrap(~time_step_ahead)+
  #facet_grid(rows=vars(zone),cols=vars(time_step_ahead),
  #  labeller=labeller(zone=zoneName))+
  xlim(1,0)+
  geom_line(size=1)+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  xlab("Specificity")+
  ylab("Sensitivity")+
  scale_color_manual(values=c("blue","green","grey","orange","red"))+
  ggrepel::geom_text_repel(
    data=class_out_roc_curve%>%
      mutate(Thres = ifelse(Thres>1,1,ifelse(Thres<0,0,Thres)))%>%
      mutate(
        Thres=plyr::round_any(Thres,0.01),
        label=sprintf("%s %s: Sens-%s, Spec-%s, BA-%s",ifelse(model=="raw","━",'- -'),Thres,round(Sens,2),round(Spec,2),round(BA,2)),
        )%>%
        filter(ramount==0.1,zone==1,model=="downscaled" & Thres %in% c(0.50,0.30) | model!="downscaled" & Thres == 0.50)%>%
      distinct(Thres,zone,model,time_step_ahead,.keep_all = T),
    aes(label=label),
    nudge_x = 0.2,
    nudge_y = -0.2,
    hjust=0,
    cex=3,
    direction="y",
    force=0.5,
    show.legend = F,
    col="black"
  )

tiff(filename="Figure9.tiff",res=1900,width=22,height=22,units="cm",compression="lzw")
rain_roc_curve
dev.off()

rain_roc_curve
```


```{r plot skill by leadtime at thresh35, fig.cap='Figure 10. Classification Skill for rainfall>0.2 mm at a threshold of 0.35.Figure shows balanced accuracy, Sensitivity and specificity by lead time for each zone Giru/Barratta () Upper Haugton/Clare (), Millaroo/Dalbeg (), Home Hill/Mona Park(), Ayr/Brandon() for both the raw (solid) and downscaled (dashed) models.',fig.height=22/2.54,fig.width=22/2.54,echo=FALSE,warning=FALSE,message=FALSE,eval=FALSE}

rain_class_skill = class_out_roc_curve%>%
    filter(
        ramount==0.2,
        model!="naive",
        model=='downscaled' & round(Thres,4)==0.3275 | model=="raw" & Thres==0.5
        )%>%
    pivot_longer(names_to="measure",cols=c(Sens,Spec,BA))%>%
    mutate(
        zone=factor(
              zone,
              levels=c(1,2,3,4,5),
              labels=c("Giru/Barratta","UpperHauton/Clare","Millaroo/Dalbeg","HomeHill/MonaPark","Ayr/Brandon")
                  )
        )%>%
    ggplot(
        aes(
            x=time_step_ahead,
            y=value,
            col=zone,
            shape=zone,
            linetype=model)
        )+
    facet_grid(rows=vars(measure),scales="free_y")+
    #facet_grid(rows=vars(zone),cols=vars(measure),
    #  labeller=labeller(zone=zoneName))+
    geom_line(size=1)+
    geom_point(size=2)+
    theme_bw()+
    xlab("lead time (days)")+
    ylab("Score")+
    scale_color_manual(values=c("blue","green","grey","orange","red"))


tiff(filename="Figure10.tiff",res=1900,width=22,height=22,units="cm",compression="lzw")
rain_class_skill
dev.off()

rain_class_skill
```

## Irrigation events forecasts

As with rainfall wet day classification, irrigation classification AUC was highest for the downscaled model at all lead times and all zones (Figure 9). A unique feature of the irrigation forecast skill was the perfect scores for day one (lead time = 0). This was due to the scheduling of events in APSIM. Irrigation occurs at the start of the day before the days rainfall is account for. This means that the schedule is triggered by the soil water deficit from the end of the previous day and isn’t affected by the rainfall forecast.

In contrast to the rainfall classification, the naïve forecast model skill was not static. The AUC score of the naive model decreased at longer lead times but was generally higher than or similar to the raw forecast and lower than the downscaled forecast. Naive model tended to have similar or higher Sensitivity than the downscaled model but lower Specificity. This is likely due to the assumption of no rainfall. As no rainfall is assumed, the naive model is likely to correctly guess irrigation events during drier periods but will have lower skill during wet periods. 

In general across climate zones the downscaled forecast model had higher Sensitvity and similar or higher Specificity than the raw forecasts. In particular, at longer lead times the Specificity of the raw forecast dropped off while the Specificity of the naive model remained high. For all models, the Specificty was high (> 0.9) while the Sensitivity was quite low at longer lead times (< 0.5). This suggests that it may be difficult to forecast a SWD triggered irrigation event in advance. The greatest improvement in overall skill AUC seen when the downscaled model is used is derived from a better Specificity (lower chance of predicting an irrigation when none is required) associated with including a chance of rainfall. As with the wet day forecasts, Sensitivity could be improved when the downscaled forecasts are used, by changing the probability at which an irrigation event is considered to have occurred. Preliminary results suggested that a cut-off of 0.1 (10% chance of irrigation) would increase the Sensitivity without greatly reducing the overall Balanced Accuracy (data not shown). In practice, selecting a ‘cut-off’ point would require input from industry and may differ for growers with different risk profiles. Future research could consider the impact on yields to cost ratio of using the irrigation forecast in scheduling.

```{r irrigation roc,echo=FALSE,warning=FALSE,message=FALSE}
set = expand.grid(
  zone=c(1,2,3,4,5),
  tstep=c(0,1,2,3,4,5,6),
  model=c("naive","downscaled","raw")
)

irrig_factor = 
  apsim_database%>%
    filter(model=="pp")%>%
  left_join(
    apsim_database%>%
        filter(model=="obs"),
    by=c("Date"="Date","zonename"="zonename","zonenumber"="zonenumber"))%>%
    mutate(
      obs_irrig = ifelse(irrigation.y==60,"wet","dry"),
      pred_irrig = ifelse(irrigation.x==60,"wet","dry"),
      Date = as.Date(Date,"%d/%m/%Y")
      )%>%
    filter(Date < as.Date("2020-09-08") | (Date > as.Date("2020-11-06") & Date < as.Date("2021-10-04")))%>%
    group_by(zonenumber,Date,time_steps_ahead.x)%>%
    summarize(
      obs = obs_irrig[1],
      wet = sum(ifelse(pred_irrig == "wet",1,0))/length(pred_irrig),
      dry = sum(ifelse(pred_irrig == "dry",1,0))/length(pred_irrig)
    )%>%
    ungroup()%>%
    rowwise()%>%
    mutate(
      pred = factor(ifelse(wet>dry,"wet","dry"),levels=c("wet","dry")),
      obs = factor(obs,levels=c("wet","dry"))
      )%>%
    ungroup()%>%
    mutate(
      model="downscaled"
    )%>%
      bind_rows(
        apsim_database%>%
            filter(model=="naive")%>%
          left_join(
            apsim_database%>%filter(model=="obs"),
            by=c("Date"="Date","zonename"="zonename","zonenumber"="zonenumber")
            )%>%
          mutate(
            obs_irrig = ifelse(irrigation.y==60,"wet","dry"),
            pred_irrig = ifelse(irrigation.x==60,"wet","dry"),
            Date = as.Date(Date,"%d/%m/%Y")
            )%>%
          filter(Date < as.Date("2020-09-08") | (Date > as.Date("2020-11-06") & Date < as.Date("2021-10-04")))%>%
          group_by(zonenumber,Date,time_steps_ahead.x)%>%
          summarize(
            obs = obs_irrig[1],
            wet = sum(ifelse(pred_irrig == "wet",1,0))/length(pred_irrig),
            dry = sum(ifelse(pred_irrig == "dry",1,0))/length(pred_irrig)
            )%>%
          ungroup()%>%
          rowwise()%>%
          mutate(
            pred = factor(ifelse(wet>dry,"wet","dry"),levels=c("wet","dry")),
            obs = factor(obs,levels=c("wet","dry")),
            )%>%
          ungroup()%>%
          mutate(
            model="naive"
          ),
        apsim_database%>%filter(model=="raw")%>%
          left_join(
            apsim_database%>%filter(model=="obs"),
            by=c("Date"="Date","zonename"="zonename","zonenumber"="zonenumber")
            )%>%
          mutate(
            obs_irrig = ifelse(irrigation.y==60,"wet","dry"),
            pred_irrig = ifelse(irrigation.x==60,"wet","dry"),
            Date = as.Date(Date,"%d/%m/%Y")
            )%>%
          filter(Date < as.Date("2020-09-08") | (Date > as.Date("2020-11-06") & Date > as.Date("2021-10-04")))%>%
          group_by(zonenumber,Date,time_steps_ahead.x)%>%
          summarize(
            obs = obs_irrig[1],
            wet = sum(ifelse(pred_irrig == "wet",1,0))/length(pred_irrig),
            dry = sum(ifelse(pred_irrig == "dry",1,0))/length(pred_irrig)
            )%>%
          ungroup()%>%
          rowwise()%>%
          mutate(
            pred = factor(ifelse(wet>dry,"wet","dry"),levels=c("wet","dry")),
            obs = factor(obs,levels=c("wet","dry")),
            )%>%
          ungroup()%>%
          mutate(
            model="raw"
          )
      )

irrig_out = foreach(
  z = set$zone,
  t = set$tstep,
  m = set$model,
  .combine="rbind"
  )%do%{
    xx = caret::twoClassSummary(
      as.data.frame(
        irrig_factor
        )%>%
        filter(
          zonenumber==z,
          time_steps_ahead.x==t,
          model==m
          ),
      lev=c("wet","dry")
      )
    data.frame(
      "zonenumber"=z,
      "time_step_ahead"=t,
      "model"=m,
      "AUC"=xx[["ROC"]],
      "Sens"=xx[["Sens"]],
      "Spec"=xx[["Spec"]],
      "BA"=(xx[["Sens"]]+xx[["Spec"]])/2
      )
  }

irrig_out_roc_curve = foreach(
  t = set$tstep,
  m = set$model,
  z = set$zone,
  .combine="rbind"
  )%do%{
    if(m=="downscaled" & z>5){
      out = data.frame(
        "zone"=z,
        "time_step_ahead"=t,
        "model"=m,
        "Sens"=NA,
        "Spec"=NA,
        "Thres"=NA,
      "BA"=NA  
      )
    } else{
      xx = pROC::roc(
        obs~wet,
        irrig_factor%>%
          filter(
            time_steps_ahead.x==t,
            model==m,
            zonenumber==z,
            )%>%
        mutate(obs=factor(obs,ordered=T,levels=c("dry","wet")))
      )
      out = data.frame(
      "zone"=z,
      "time_step_ahead"=t,
      "model"=m,
      "Sens"=xx$sensitivities,
      "Spec"=xx$specificities,
      "Thres"=xx$thresholds,
      "BA"=(xx$sensitivities+xx$specificities)/2
      )
    }
  }

irrig_out%>%
  pivot_longer(
    cols=c("AUC","BA","Sens","Spec"),
    names_to = "measure"
    )%>%
  pivot_wider(
    id_cols=c("zonenumber","measure","model"),
    names_from = "time_step_ahead",
    values_from = "value"
    )%>%
  mutate(
    model=factor(model,levels=c("naive","raw","downscaled"),ordered=T),
    measure = factor(
      measure,
      levels=c("ROC","BA","Sens","Spec"),
      labels=c("AUC","BA","Sens","Spec")
      )
    )%>%
  arrange(zonenumber,measure,model)%>%
  group_by(zonenumber,measure,model)%>%
  transmute(across(where(is.numeric),round,digits=2))%>%
  write.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/model_skill_unfiltered.csv")

```

<!-- ROC curves in Figure 9 suggest that specificity could be increased at longer lead times by using a lower cut-off value. This would increase the balanced accuracy but would reduce the Specificity. Specificity of raw and naïve models across all zones and lead times never dropped below 0.96. So to maintain model performance a cut-off value should not result in a Spec of less than 0.96. The roc curves in Figure 10 suggest that improved sensitivity with a specificity of >=0.96 should use a cut-off of around 0.1 – 0.3. Unlike wet day forecasts the ‘optimum’ cut-off for a balanced predictor is not consistent across zones. However, it appears that cut-offs would achieve similar results at all lead times for a particular zone. The particularly low performance in zones 4 and 5 suggest that we need better rainfall forecasts in those regions.    -->


```{r plot irrigation skill by leadtime, fig.cap="Figure 9. Irrigation Classification Skill by lead times and zones. Rows represent zones while columns represent lead times. ",fig.height=22/1.5/2.54,fig.width=22/2.54,echo=FALSE,warning=FALSE,message=FALSE}

irrigation_skill_plot=irrig_out%>%
  mutate(model=ifelse(model=="pp","downscaled",as.character(model)))%>%
  mutate(model=factor(model,levels=c("downscaled","naive","raw"),labels=c("downscaled","naive","raw")))%>%
  pivot_longer(names_to="measure",cols=c(AUC,Sens,Spec,BA))%>%
    ggplot(
        aes(
            x=time_step_ahead,
            y=value,
            col=model)
        )+
    #facet_grid(rows=vars(measure),scales="free_y")+
    facet_grid(rows=vars(measure),cols=vars(zonenumber),scales="free_y",
    labeller=labeller(zonenumber=zoneName))+
    geom_bar(stat="identity",position="dodge")+
    theme_bw()+
    xlab("lead time (days)")+
    ylab("Irrigation event skill score")+
    scale_color_manual(values=c("downscaled"='#66c2a5',"naive"="#8da0cb","raw"='#fc8d62'))+


tiff(filename="Figure11.tiff",res=1900,width=24,height=22/1.5,units="cm",compression="lzw")
irrigation_skill_plot
dev.off()


irrigation_skill_plot
```


<!-- ROC curves in Figure 11 suggest that specificity could be increased at longer lead times by using a lower cut-off value. This would increase the balanced accuracy but would reduce the Specificity. Specificity of raw and naïve models across all zones and lead times never dropped below 0.96. So to maintain model performance a cut-off value should not result in a Spec of less than 0.96. The roc curves in Figure 11 suggest that improved sensitivity with a specificity of >=0.96 should use a cut-off of around 0.1 – 0.3. Unlike wet day forecasts the ‘optimum’ cut-off for a balanced predictor is not consistent across zones. However, it appears that cut-offs would achieve similar results at all lead times for a particular zone. The particularly low performance in zones 4 and 5 suggest that we need better rainfall forecasts in those regions.     -->


```{r plot roc curve for irrig days, fig.cap="Figure 12. ROC curves for irrigation days. Grey dashed line represents naive classifier.Rows represent lead times, while Columns represent climate zones.",fig.height=22/2.54,fig.width=22/2.5,echo=FALSE,warning=FALSE,message=FALSE,eval=FALSE}

txtdata=irrig_out_roc_curve%>%
      mutate(
        Thres=plyr::round_any(Thres,0.1),
        label=sprintf("%s %s: Sens-%s, Spec-%s, BA-%s",ifelse(model=="naive","━",ifelse(model=='downscaled','- -','━ ━')),Thres,round(Sens,2),round(Spec,2),round(BA,2)),
        )%>%
    mutate(
        zone=factor(
              zone,
              levels=c(1,2,3,4,5),
              labels=c("Giru/Barratta","UpperHauton/Clare","Millaroo/Dalbeg","HomeHill/MonaPark","Ayr/Brandon")
                  )
        )%>%
      distinct(Thres,model,zone,time_step_ahead,.keep_all = T)%>%
      mutate(Thres = ifelse(Thres>1,1,ifelse(Thres<0,0,Thres)))%>%
        filter(Thres %in% c(0.5,0.1,0.05) & model=="downscaled" | model!="downscaled" & Thres==0.5)%>%
        filter(zone=="Giru/Barratta")

irrigation_roc_curves=irrig_out_roc_curve%>%
  mutate(Thres = ifelse(Thres>1,1,ifelse(Thres<0,0,Thres)))%>%
    mutate(
        zone=factor(
              zone,
              levels=c(1,2,3,4,5),
              labels=c("Giru/Barratta","UpperHauton/Clare","Millaroo/Dalbeg","HomeHill/MonaPark","Ayr/Brandon")
                  )
        )%>%
  filter(zone=="Giru/Barratta")%>%
  ggplot(aes(x=Spec,y=Sens,linetype=model,shape=zone))+
  facet_wrap(~time_step_ahead)+
  #facet_grid(rows=vars(time_step_ahead),cols=vars(zone),
  #  labeller=labeller(zone=zoneName))+
  xlim(1.05,-0.05)+ylim(-0.05,1.05)+
  geom_path(size=1,col="blue")+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  ggrepel::geom_text_repel(
    data=txtdata,
    aes(label=label,x=Spec,y=Sens,lty=model),
    col="black",
    nudge_x = 0.2,
    nudge_y = -0.2,
    hjust=0,
    direction="y",
    force=0.5,
    cex=3,
    show.legend = F
  )+
  scale_color_manual(values=c("blue","green","grey","orange","red"))+
    labs(x="Specificity",y="Sensitivity")

tiff(filename="Figure12.tiff",res=1900,width=22,height=22,units="cm",compression="lzw")
irrigation_roc_curves
dev.off()

irrigation_roc_curves

```


```{r plot irrigation skill by leadtime01, fig.cap="Figure 11. Irrigation Classification Skill by lead times and zones. Rows represent zones while columns represent lead times. ",fig.height=22/1.5/2.54,fig.width=22/2.54,echo=FALSE,warning=FALSE,message=FALSE,eval=FALSE}

irrigation_skill_plot=irrig_out_roc_curve%>%
    group_by(zone,time_step_ahead)%>%
    filter(abs(Thres-0.1) == min(abs(Thres - 0.1)) & model=="downscaled" | Thres==0.5 & model !="downscaled")%>%
    ungroup()%>%
  pivot_longer(names_to="measure",cols=c(Sens,Spec,BA))%>%
    mutate(
        zone=factor(
              zone,
              levels=c(1,2,3,4,5),
              labels=c("Giru/Barratta","UpperHauton/Clare","Millaroo/Dalbeg","HomeHill/MonaPark","Ayr/Brandon")
                  )
        )%>%
    ggplot(
        aes(
            x=time_step_ahead,
            y=value,
            col=zone,
            shape=zone,
            linetype=model)
        )+
    facet_grid(rows=vars(measure),cols=vars(zone),scales="free_y")+
    #facet_grid(rows=vars(zone),cols=vars(measure),
    #  labeller=labeller(zone=zoneName))+
    geom_line(size=1)+
    geom_point(size=2)+
    theme_bw()+
    xlab("lead time (days)")+
    ylab("Score")+
    scale_color_manual(values=c("blue","green","grey","orange","red"))


tiff(filename="Figure12.tiff",res=1900,width=22/1.5,height=22,units="cm",compression="lzw")
irrigation_skill_plot
dev.off()


irrigation_skill_plot
```


# Conclusions

This study considered the use of a novel downscaled weather forecasts to provide forecasts for the likelihood of upcoming irrigation events. Results showed that the downscaled model improved forecasts daily rainfall totals, maximum and minimum temperature compared to the raw forecasts. Downscaled forecasts also outperformed the naive forecast based on the historical monthly temperature averages and assumption of no rainfall. Interestingly, an assumption of no rainfall often outperformed raw forecasts in terms of CRPS at longer lead times. The improved climate forecasts appeared to lead to an improvement in irrigation event classification based on AUC, especially at later lead times. This was likely due to a reduction in false negatives (i.e. an improved ability to identify when an irrigation will not be required). These results show that the downscaled forecasts should be used for agricultural forecasting tasks. Futher research is needed to identify how use of these forecasts would impact irrigation and cost efficiency.

```{r seasonal irrigation roc,message=F,warning=F,eval=F}
cl = makeCluster(20)
registerDoParallel(cl)

set = expand.grid(
  zone=c(1,2,3,4,5),
  tstep=c(0,1,2,3,4,5,6),
  model=c("naive","downscaled","raw"),
  season=c("Spring","Summer","Autumn","Winter")
)

seasonal_irrig_out = foreach(
  z = set$zone,
  t = set$tstep,
  m = set$model,
  s = set$season,
  .combine="rbind",
  .packages = c("dplyr","caret","pROC"),
  .export=c('irrig_factor')
  )%dopar%{
    xx = caret::twoClassSummary(
      as.data.frame(
        irrig_factor%>%
        mutate(
          season=
            ifelse(
              format(as.Date(Date),"%m") %in% c("01","02","12"),
              "Summer",
              ifelse(
                format(as.Date(Date),"%m") %in% c("03","04","05"),
                "Autumn",
                ifelse(
                format(as.Date(Date),"%m") %in% c("06","07","08"),
                "Winter",
                "Spring"
                )
              )
            )
        )%>%
        filter(
          zonenumber==z,
          time_steps_ahead.x==t,
          model==m,
          season==s
          )
        ),
      lev=c("wet","dry")
      )
    data.frame(
      "zonenumber"=z,
      "time_step_ahead"=t,
      "season"=s,
      "model"=m,
      "AUC"=xx[["ROC"]],
      "Sens"=xx[["Sens"]],
      "Spec"=xx[["Spec"]],
      "BA"=(xx[["Sens"]]+xx[["Spec"]])/2
      )
  }

seasonal_irrig_out_roc_curve = foreach(
  t = set$tstep,
  m = set$model,
  z = set$zone,
  s = set$season,
  .combine="rbind",
  .packages = c("dplyr","caret","pROC"),
  .export=c('irrig_factor')
  )%dopar%{
    xx = pROC::roc(
        obs~wet,
        irrig_factor%>%
        mutate(
          season=
            ifelse(
              format(as.Date(Date),"%m") %in% c("01","02","12"),
              "Summer",
              ifelse(
                format(as.Date(Date),"%m") %in% c("03","04","05"),
                "Autumn",
                ifelse(
                format(as.Date(Date),"%m") %in% c("06","07","08"),
                "Winter",
                "Spring"
                )
              )
            )
        )%>%
          filter(
            time_steps_ahead.x==t,
            model==m,
            zonenumber==z,
            season==s,
            )%>%
        mutate(obs=factor(obs,ordered=T,levels=c("dry","wet")))
      )
      out = data.frame(
      "zone"=z,
      "time_step_ahead"=t,
      "model"=m,
      "season"=s,
      "Sens"=xx$sensitivities,
      "Spec"=xx$specificities,
      "Thres"=xx$thresholds,
      "BA"=(xx$sensitivities+xx$specificities)/2
      )
  }

seasonal_irrig_out%>%
  pivot_longer(
    cols=c("ROC","BA","Sens","Spec"),
    names_to = "measure"
    )%>%
  pivot_wider(
    id_cols=c("zonenumber","measure","model","season"),
    names_from = "time_step_ahead",
    values_from = "value"
    )%>%
  mutate(
    model=factor(model,levels=c("naive","raw","downscaled"),ordered=T),
    measure = factor(
      measure,
      levels=c("ROC","BA","Sens","Spec"),
      labels=c("AUC","BA","Sens","Spec")
      )
    )%>%
  arrange(zonenumber,season,measure,model)%>%
  group_by(zonenumber,season,measure,model)%>%
  transmute(across(where(is.numeric),round,digits=2))%>%
  write.csv("C:/Users/jc227226/Dropbox/CSSIP_justin/Skill Paper/seasonal_model_skill.csv")

stopCluster(cl)
rm(cl)

```

```{r plot irrigation skill by season/leadtime, fig.cap="Irrigation Classification Skill. Rows represent lead times while colums represent zones. For each zone the downscaled forecast approaches the raw forecast at longer leadtimes.",fig.height=9,fig.width=15,eval=F}

seasonal_irrig_out%>%
  pivot_longer(names_to="measure",cols=c(ROC,Sens,Spec,BA))%>%
  ggplot(aes(x=time_step_ahead,y=value,col=model))+
  facet_grid(rows=vars(zonenumber),cols=vars(season,measure))+
  geom_line(size=1)+
  theme_bw()+
  xlab("lead time (days)")+
  ylab("Score")
```



<!-- #Supplementary Material -->
<!-- ##Rainfall classification skill of higher rainfall events -->

```{r plot roc curve for wet daysS1, fig.cap="Figure S1: ROC curves for rainfall>0.1 mm. Grey dashed line represents naive classifier.Rows represent lead times while colums represent zones. For each zone the downscaled forecast approaches the raw forecast at longer leadtimes.",eval=F,fig.height=9,fig.width=9}

class_out_roc_curve%>%
  filter(ramount==0.1)%>%
  ggplot(aes(x=Spec,y=Sens,col=model))+
  facet_grid(rows=vars(time_step_ahead),cols=vars(zone))+
  xlim(1,0)+
  geom_line(size=1)+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  xlab("Specificity")+
  ylab("Sensitivity")
```

```{r plot roc curve for wet days 5, fig.cap="Figure S2: ROC curves for rainfall>5 mm. Grey dashed line represents naive classifier.Rows represent lead times while colums represent zones. For each zone the downscaled forecast approaches the raw forecast at longer leadtimes.",eval=F,fig.height=9,fig.width=9}

class_out_roc_curve%>%
    filter(ramount==5)%>%
  ggplot(aes(x=Spec,y=Sens,col=model))+
  facet_grid(rows=vars(time_step_ahead),cols=vars(zone))+
  xlim(1,0)+
  geom_line(size=1)+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  xlab("Specificity")+
  ylab("Sensitivity")
```

```{r plot roc curve for wet days 10, fig.cap="Figure S3: ROC curves for rainfall>10 mm. Grey dashed line represents naive classifier.Rows represent lead times while colums represent zones. For each zone the downscaled forecast approaches the raw forecast at longer leadtimes.",eval=F,fig.height=9,fig.width=9}

class_out_roc_curve%>%
    filter(ramount==10)%>%
  ggplot(aes(x=Spec,y=Sens,col=model))+
  facet_grid(rows=vars(time_step_ahead),cols=vars(zone))+
  xlim(1,0)+
  geom_line(size=1)+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  xlab("Specificity")+
  ylab("Sensitivity")
```

```{r plot roc curve for wet days 20, fig.cap="Figure S4: ROC curves for rainfall>20 mm. Grey dashed line represents naive classifier.Rows represent lead times while colums represent zones. For each zone the downscaled forecast approaches the raw forecast at longer leadtimes.",eval=F,fig.height=9,fig.width=9}

class_out_roc_curve%>%
    filter(ramount==20)%>%
  ggplot(aes(x=Spec,y=Sens,col=model))+
  facet_grid(rows=vars(time_step_ahead),cols=vars(zone))+
  xlim(1,0)+
  geom_line(size=1)+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  xlab("Specificity")+
  ylab("Sensitivity")
```




```{r plot correlation rainfall,echo=F,message=F,warning=F,fig.height=5,fig.width=4,eval=F}
rain_skill_out%>%
  ggplot(aes(x=time_step_ahead,y=corr,col=model))+
  geom_line(size=1)+
  facet_wrap(
    ~zone,
    scales="free_y",
    ncol = 1,
    labeller=labeller(zone=zoneName)
    )+
  theme_bw()+
  xlab("lead time (days)")
```



```{r rainfall forecast example wet,echo=F,message=F,warning=F,fig.height=10,fig.width=10,eval=F}


downscaled%>%
  mutate(
    time_step_ahead = time_step_ahead + 1,
    datetime = as.Date(date,"%Y%m%d") + time_step_ahead,
    )%>%
  mutate(
    zone = ifelse(
      zone=="blue",1,ifelse(
        zone=="green",2,ifelse(
          zone=="grey",3,ifelse(
            zone=="orange",4,5)
          )
        )
      )
    )%>%
  left_join(
    obs%>%
      mutate(silo_date = as.Date(datetime,"%Y-%m-%d")),
    by=c("datetime"="datetime","zone"="zone")
    )%>%
  left_join(
    raw%>%
      mutate(
        file_date = as.Date(date,"%Y%m%d"),
        forecast_date_j = as.Date(date,"%Y%m%d") + time_step_ahead + 1,
        datetime = as.Date(date,"%Y%m%d") + time_step_ahead,
      )%>%
      mutate(
        zone = ifelse(
          zone=="blue",1,ifelse(
            zone=="green",2,ifelse(
              zone=="grey",3,ifelse(
                zone=="orange",4,5)
              )
            )
          )
        ),
    by=c("datetime"="datetime","zone"="zone","time_step_ahead"="time_step_ahead")
    )%>%
  filter(datetime == "2021-03-01" | datetime=="2020-01-28")%>%View()
  ggplot(aes(x=as.factor(time_step_ahead),y=precip.x,col=as.factor(datetime)))+
  geom_boxplot()+
  geom_hline(aes(yintercept=daily_rain,col=as.factor(datetime)))+
  geom_point(aes(y=precip.y),position=position_dodge(width=0.75),pch=5,size=2,stroke=2)+
  facet_wrap(
    ~zone,
    ncol = 1,
    labeller=labeller(zone=zoneName)
    )+
  theme_bw()

```

```{r plot roc curve for wet days 50, fig.cap="Figure S5: ROC curves for rainfall>50 mm. Grey dashed line represents naive classifier.Rows represent lead times while colums represent zones.",fig.height=9,fig.width=9,eval=F}

class_out_roc_curve%>%
    filter(ramount==50)%>%
  ggplot(aes(x=Spec,y=Sens,col=model))+
  facet_grid(rows=vars(time_step_ahead),cols=vars(zone))+
  xlim(1,0)+
  geom_line(size=1)+
  geom_abline(slope=1,intercept=1,linetype="dashed",col="grey",size=1)+
  theme_bw()+
  xlab("Specificity")+
  ylab("Sensitivity")
```

<!--
#################################
#########  Extra Setup  #########
#################################
-->

<!--
# Storage 
-->

<!--
## raw forecasts

This converts nc files to a single csv which is easier to deal with in R when 
creating the met files.
Here we store the raw forecasts, this currently uses the raw.nc from Andrew
which are alot easier to deal with than the old individual files.

-->

```{r storing raw forecasts,eval=F}

# Raw nc file

raw = foreach(loc = c("blue","green","orange","red","grey"),.combine='rbind')%do%{
    data_array <- tidync(sprintf("F:/access_g_raw/%s_access_g_raw.nc",loc))
    data_array %>%
        hyper_tibble() %>%
        mutate(
            zone=loc,
            ensemble=1,
            date=format(as.Date("1970-01-01","%Y-%m-%d")+time,"%Y%m%d"),
            time_step_ahead = day,
            precip=rain,
            tmax=tmax,
            tmin=tmin
        )%>%
        select(zone,ensemble,date,time_step_ahead,precip,tmax,tmin)
}

# individual files
"
raw_files = list.files(wspace_g3,'rainfall_[0-9]*.nc',full.names=T)
cl=makeCluster(20)
registerDoParallel(cl)
rain <- foreach(
      f =  raw_files,
      .combine='rbind',
      .packages=c('tidync','dplyr')
      )%dopar%{ 
  data_array <-tidync(f)
  data_array %>% 
    hyper_tibble() %>% 
    mutate(
      date = substr(strsplit(f,"_")[[1]][6],1,8),
      zone = strsplit(f,"_")[[1]][4]
    )
}
raw_files = list.files(wspace_g3,'tmax_[0-9]*.nc',full.names=T)
tmax <- foreach(
      f =  raw_files,
      .combine='rbind',
      .packages=c('tidync','dplyr')
      )%dopar%{ 
  data_array <-tidync(f)
  data_array %>% 
    hyper_tibble() %>% 
    mutate(
      date = substr(strsplit(f,"_")[[1]][6],1,8),
      zone = strsplit(f,"_")[[1]][4]
    )
}
raw_files = list.files(wspace_g3,'tmin_[0-9]*.nc',full.names=T)
tmin <- foreach(
      f =  raw_files,
      .combine='rbind',
      .packages=c('tidync','dplyr')
      )%dopar%{ 
  data_array <-tidync(f)
  data_array %>% 
    hyper_tibble() %>% 
    mutate(
      date = substr(strsplit(f,'_')[[1]][6],1,8),
      zone = strsplit(f,'_')[[1]][4]
    )
}

raw = rain %>%
  left_join(tmax) %>%
  left_join(tmin)
#rm(rain,tmax,tmin)
"
write.csv(raw, "F:/access_g_raw_forecasts.csv")
```

<!--
## downscaled forecasts

This converts nc files to a single csv which is easier to deal with in R when 
creating the met files. This converts the new (2022) down-scaled, cross validated
files. These are in a slightly different format to previously.
-->

```{r storing downscaled forecasts,eval=F}
wspace_g3_downscaled = "F:/access.opticane.net/historical/access-g-aps3/pp_2022/"
cl=makeCluster(25)
registerDoParallel(cl)

downscaled_files = list.files(wspace_g3_downscaled,full.names=T)
downscaled = foreach(
    f =  downscaled_files,
    .combine='rbind',
    .packages=c('tidync','dplyr')
    )%dopar%{
        data_array <-tidync(f)
        data_array %>%
            hyper_tibble() %>% 
            mutate(
                date = strsplit(strsplit(f,"/")[[1]][6],"_")[[1]][1],
                zone = strsplit(strsplit(f,"/")[[1]][6],"_")[[1]][2],
                time_step_ahead = day,
                precip=rain,
                ensemble=ens_mem,
                )%>%
            select(
                date,zone,time_step_ahead,ensemble,precip,tmax,tmin
            )
        }

write.csv(downscaled,"F://access_g_pp_forecasts.csv")
stopCluster(cl)
rm(cl)
```


<!--
## silo observations

This converts nc files to a single csv which is easier to deal with in R when 
creating the met files. This converts Andrews version of 'observed'
files. This is different to what I used originally but is probably better to use
as it is the observations on which the the down-scaling is based.
-->

```{python getting weather data for silo code, echo=F, message=F, warning=F, eval=F}

import requests
import os
import numpy as np
import pandas as pd
from datetime import datetime, timedelta, timezone
import json
from functools import reduce
import time
import logging
from logging import DEBUG

def getsilodasjson(
  lat, lon, zoneid, varstr="RXNJEHG", start=None, stop=None,
  region='Burdekin', model='silo', usr='justin.sexton1@jcu.edu.au', pwd='cssip'
  ):
    """
    Reads data from the SILO data drill database in json format
    
    Parameters
    ------------
    lat : float, required
      The latitude of the location requested in decimal degrees to the nearest 0.05 decimal degrees.
    lon : float, required
      The longitude of the location requested in decimal degrees to the nearest 0.05 decimal degrees.
    zoneid : float, required
      An extra identifier defining the zone the location belongs to. This is required but is simply passed through to
      the output. 
    varstr : string, required 
        A string defining which climate variables are to be included in the output. The default reads in radiation(J),
         maximum temperature(X),minimum temperature(N), rainfall(R), RH max(H), RH min(G), and pan evaporation(E). 
         For a full list of available parameters see: https://www.longpaddock.qld.gov.au/silo/about/climate-variables/
    start : string, optional 
        The start date of the period requested. Must be a string of the format 'yyyymmdd'. if not supplied, 
        start of today - 7 is used.
    stop : string, optional
        The end date of the period requested. Must be a string of the format 'yyyymmdd'. if not supplied,
         end of yesterday is used.
    region : string, 
        an extra identifier defining the 'region' the data belongs to. It is simply passed through to the output.
    model : string, 
        an extra identifier defining the 'model' the data belongs to. 
        Unless specifically required this should be left as 'silo'. It is simply passed through to the output.
    usr : string, 
        The email address of the silo user. This should work with any email address now, but one is still required.
         It is not returned in the output. 
    pwd : string, 
        The password of the silo user. This is not an actual password anymore but is still required in the query.
         This is used now more to identify the purpose/project the data was downloaded for. 
         It is not returned in the output.

    Returns
    ----------
    list 
        A python list of dictionaries with each entry an observation (day). 
        This can easily be transformed into a pandas dataframe.
    """
    # define the url of the silo datadrill api.
    url="https://www.longpaddock.qld.gov.au/cgi-bin/silo/DataDrillDataset.php"
    # set up a today variable
    today = datetime.utcnow()
    todayaest = datetime.utcnow() + timedelta(hours=10)
    def extract_vars(x1,x2):
        """
        An internal function (reducer) to return a dictionary with key = variable_code and value = 'value'
        this makes it easier to reshape the data.
        
        """
        x1[x2['variable_code']]=x2['value']
        return x1
    def reshape(a):
        """
        An internal function (mapper) to reshape the silo json into a more useful list of dictionaries
        For each entry (a) an intial dictionary containing date, location and extra supplied variables is created.
        the reducer is then used to add each variable to the dictionary in key,value pairs.
        The final output is a list of dictionaries representing all entries.        
        """
        return reduce(
            extract_vars,
            a['variables'],
            {
                'region': region, 'zone': zoneid,
                'extracted': today.strftime("%Y-%m-%dT%H:%M:%SZ"),
                'model': model, 'lat': lat, 'lon': lon, 'datetime': a['date']
            }
        )
    # check if dates are present else use defaults
    # the defaults are to pull data for the last week ending yesterday
    # days are based on AEST as this is the assumed timezone of silo
    # I've enforced this by first forcing into utc time and then adding 10 hours
    # this should work locally and on a server
    if not isinstance(stop, str): 
        stop = todayaest - timedelta(days=1)
        stop = stop.strftime("%Y%m%d")
    if not isinstance(start, str): 
        start = todayaest - timedelta(days=7)
        start = start.strftime("%Y%m%d")
    # this concatenates the url and the query parameters
    # note here that we always grab data as a json
    url = url+"?start={}&finish={}&lat={}&lon={}&format=json&comment={}&username={}&password={}".format(
        start, stop, lat, lon, varstr, usr, pwd
    )
    r = requests.get(url)
    if r.status_code != 200:
        print("Got http status {} when fetching url `{}`".format(r.status_code, url))
    # parse the body as json this returns a dictionary
    http_payload = json.loads(r.text)
    data = http_payload['data']
    # map the data into a dictionary that should be able to be parsed by pandas/numpy into a dataframe
    outdata = map(reshape, data)
    return outdata

def getzonesilodata(start=None,stop=None):
    """
    getZoneSILOdata is a wrapper around getSILOddasjson.
    It downloads a bunch of points for each zone and averages them to get a zone value
    It also calculates CWU from the averaged data
    """
    print('-------------------------------------------------------------------')
    print('----------Collecting SILO observations for 5 climate zones---------')
    print('-------------------------------------------------------------------')
    locations = [
      {
        'region':'Burdekin',
        'zone':1,
        'zonename':'blue',
        'name':'Giru/Barratta',
        'lat':[
          -19.55,-19.60,
          -19.55,-19.50,
          -19.65,-19.60,
          -19.55,-19.60,
          -19.55,-19.60,
          -19.55,-19.55,
          -19.50,-19.65,
          -19.65,-19.60,
          -19.50,-19.50,
          -19.50],
        'lon':[
          147.05,147.10,
          147.10,147.10,
          147.15,147.15,
          147.15,147.20,
          147.20,147.25,
          147.25,147.30,
          147.30,147.10,
          147.05,147.05,
          147.05,147.15,
          147.20],
      },
      {
        'region':'Burdekin',
        'zone':2,
        'name':'Upper Haughton/Clare',
        'zonename':'green',
        'lat':[
          -19.85,-19.80,
          -19.75,-19.70,
          -19.90,-19.85,
          -19.80,-19.75,
          -19.85,-19.80,
          -19.80,-19.85,
          -19.90,-19.90,
          -19.85,-19.80,
          -19.75,-19.70,
          -19.70,-19.75,
          -19.70,-19.95,
          -19.95],
        'lon':[
          147.15,147.15,
          147.15,147.15,
          147.20,147.20,
          147.20,147.20,
          147.25,147.25,
          147.30,147.30,
          147.15,147.10,
          147.10,147.10,
          147.10,147.10,
          147.05,147.05,
          147.00,147.25,
          147.20],
      },
      {
        'region':'Burdekin',
        'zone':3,
        'zonename':'grey',
        'name':'Millaroo/Dalbeg',
        'lat':[
          -20.10,-20.05,
          -20.00,-20.25,
          -20.20,-20.05,
          -20.15,-20.30],
        'lon':[
          147.25,147.25,
          147.25,147.30,
          147.30,147.30,
          147.25,147.30],
      },
      {
        'region':'Burdekin',
        'zone':4,
        'name':'Home Hill/Clare',
        'zonename':'orange',
        'lat':[
          -19.70,-19.65,
          -19.75,-19.70,
          -19.65,-19.75,
          -19.70,-19.65,
          -19.60,-19.75,
          -19.70,-19.65,
          -19.80,-19.75,
          -19.70,-19.65,
          -19.75,-19.70,
          -19.65,-19.80,
          -19.75,-19.70,
          -19.65,-19.65,
          -19.80,-19.70,
          -19.75],
        'lon':[
          147.20,147.20,
          147.25,147.25,
          147.25,147.30,
          147.30,147.30,
          147.30,147.35,
          147.35,147.35,
          147.40,147.40,
          147.40,147.40,
          147.45,147.45,
          147.45,147.50,
          147.50,147.50,
          147.50,147.55,
          147.35,147.55,
          147.55],
      },
      {
        'region':'Burdekin',
        'zone':5,
        'zonename':'red',
        'name':'Ayr/Brandon',
        'lat':[
          -19.60,-19.55,
          -19.50,-19.60,
          -19.55,-19.50,
          -19.60,-19.55,
          -19.50,-19.60,
          -19.55,-19.50,
          -19.60],
        'lon':[
          147.35,147.35,
          147.35,147.40,
          147.40,147.40,
          147.45,147.45,
          147.45,147.50,
          147.50,147.50,
          147.55],
      }
    ]
    out = []
    for zone in locations:
      zoneout=[]
      print('Starting zone:{}...........'.format(zone['zone']))
      for i in range(len(zone['lat'])):
        print('...........Starting location:{} with lat:{} and lon:{}'.format(i,zone['lat'][i],zone['lon'][i]))
        zoneout += list(getsilodasjson(zone['lat'][i],zone['lon'][i],zone['zone'],"RXNJEHG",start,stop))
      
      print('...........Converting to pandas dataframe')
      zoneout = pd.DataFrame(zoneout)
      print('...........Summarizing zone:{}'.format(zone['zone']))
      grouped = zoneout.groupby('datetime', as_index=False).agg({
        'region': lambda x: x.iloc[0],
        'zone': lambda x: x.iloc[0],
        'model': lambda x: x.iloc[0],
        'extracted' : lambda x: x.iloc[0],
        'daily_rain': lambda x: np.round(np.mean(x),1),
        'max_temp': lambda x: np.round(np.mean(x),1),
        'min_temp': lambda x: np.round(np.mean(x),1),
        'rh_tmax': lambda x: np.round(np.mean(x),1),
        'rh_tmin': lambda x: np.round(np.mean(x),1),
        'radiation': lambda x: np.round(np.mean(x),1),
        'evap_pan': lambda x: np.round(np.mean(x),1),
      })
      print('...........Pushing summary of zone {} to out'.format(zone['zone']))
      if isinstance(out,list):
          out = grouped
      else:
          out = pd.concat([out,grouped])
    return out

observed = getzonesilodata(start="19700101",stop=None);
observed.to_csv(r'C:/Users/jc227226/Dropbox/CSSIP_justin/Skill Paper/observed_weather.csv', index = F, header=T);
```


```{r storing observations,eval=F}

climate_obs = read.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/observed_weather.csv")


andrew_silo_obs = foreach(loc = c("blue","green","orange","red","grey"),.combine='rbind')%do%{
    data_array <- tidync(sprintf("F:/silo_obs/%s_silo_obs.nc",loc))
    data_array %>%
        hyper_tibble() %>%
        filter(day == 1) %>%
        mutate(
            zone=loc,
            date=format(as.Date("1970-01-01","%Y-%m-%d")+time,"%Y%m%d"),
            precip=rain,
            tmax=tmax,
            tmin=tmin
        )%>%
        select(zone,date,precip,tmax,tmin)
}


write.csv(andrew_silo_obs, "F:/andrew_silo_obs.csv")
```

<!--
# Create met files 
-->

<!--
# Raw access G met files
-->

```{r Raw Access G forecasts,echo=F,message=F,warning=F,eval=F}

startdate = as.Date("2019-08-15","%Y-%m-%d")
enddate =  as.Date("2021-11-23","%Y-%m-%d")
raw = read.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/access_g_raw_forecasts.csv")

cl=parallel::makeCluster(25)
doParallel::registerDoParallel(cl)
set = expand.grid(day=seq(startdate,enddate,1),zone=c(1,2,3,4,5))
foreach(
  ddate = set$day,
  setzone = set$zone,
  .export=c("climate_obs",
            "startdate",
            "raw",
            "locations",
            "monthly_average_calculated"
            ),
  .noexport = c("downscaled","climatology_fig","monthly_averages","downscaled_files"),
  .packages=c("dplyr","readr")
  ) %dopar% {
  headertemplate=sprintf("[weather.met.weather]\nzonenumber = %s\nzonename  =  %s\nname  =  %s\nfday  =  %s\nfyear  =  %s\nlatitude = %s  (DECIMAL DEGREES)\nlongitude =  %s  (DECIMAL DEGREES)\ntav = %f (oC) ! Annual average ambient temperature\namp = %f (oC) ! Annual amplitude in mean monthly temperature.\n!\nyear day radn maxt mint rain\n()   () (MJ/m^2) (oC)  (oC)  (mm)",
                           setzone,
                           locations[[setzone]][["zonename"]],
                           locations[[setzone]][["name"]],
                           as.integer(format(as.Date(ddate), "%j")),
                           as.integer(format(as.Date(ddate), "%Y")),
                           locations[[setzone]]["center2"][[1]],
                           locations[[setzone]]["center1"][[1]],
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             mutate(
                                 daily_rain=lead(daily_rain,1),
                                 min_temp=lead(min_temp,1)
                                 )%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$tav)}),
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             group_by(zone)%>%
                             mutate(
                                 daily_rain=lead(daily_rain,1),
                                 min_temp=lead(min_temp,1))%>%
                             ungroup()%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$amp)})
                         )
  out = climate_obs%>%
      filter(zone==setzone)%>%
      mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
      mutate(
          daily_rain=lead(daily_rain,1),
          min_temp=lead(min_temp,1)
          )%>%
    filter(Date >= startdate)%>%
    filter(Date < ddate)%>%
    select(
      Date = Date,
      rain = daily_rain,
      maxt = max_temp,
      mint = min_temp,
      radiation = radiation,
    )%>%
    mutate(
      year = as.numeric(format(Date,"%Y")),
      day = as.numeric(format(Date,"%j")),
      month = as.numeric(format(Date,"%m")) 
    )%>%
    bind_rows(
      raw%>%
        filter(zone == locations[[setzone]]["zonename"])%>%
        mutate(
            time_step_ahead=time_step_ahead-1,
            Date = as.Date(as.character(date),format="%Y%m%d") + time_step_ahead
            )%>%
        mutate(fDate = as.Date(as.character(date),format="%Y%m%d"))%>%
        filter(fDate == ddate)%>%
        mutate(
          year = as.numeric(format(Date,"%Y")),
          day = as.numeric(format(Date,"%j")),
          month = as.numeric(format(Date,"%m")),
          precip = round(precip,1),
          tmax = round(tmax,1),
          tmin = round(tmin,1),
        )%>%
         left_join(
             monthly_average_calculated%>%
                 filter(zone==setzone)%>%
                 mutate(
                     month=as.numeric(month),
                     radiation=round(radiation,1)
                     )%>%
                 select(month,radiation),
             by=("month"="month")
         )%>%
        select(
          Date = Date,
          rain = precip,
          maxt = tmax,
          mint = tmin,
          radiation= radiation,
          year = year,
          day = day,
          month = month
        )
    )
#  out = out%>%
#    mutate(
#      mint=replace(
#        mint,
#        Date == ddate,
#        climate_obs%>%
#          mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
#          filter(Date == ddate, zone == setzone)%>%
#          select(min_temp)%>%pull()
#      )
#    )
  
  out = out%>%
      select(
          year,
          day,
          radn=radiation,
          maxt,
          mint,
          rain
      )
  
  writeLines(
      paste(
          headertemplate,
          readr::format_delim(out,delim="  ",col_names = FALSE),
          sep="\n"
      ),
      sprintf(
        "F:/zone_raw_mets/%s_%s_raw.met",
        locations[[setzone]][["zonename"]],
        ddate
        )
  )
}
parallel::stopCluster(cl)
rm(cl)

```



```{r downscaled Access G forecasts,echo=F,message=F,warning=F,eval=F}

startdate = as.Date("2019-08-15","%Y-%m-%d")
enddate =  as.Date("2021-11-23","%Y-%m-%d")
#access_g_downscaled = read.csv("C:/Users/jc227226/Dropbox/1. Research 2022/Research/ForecastSkill/data/access_g_pp_forecasts.csv")

cl=parallel::makeCluster(20)
doParallel::registerDoParallel(cl)
set = expand.grid(day=seq(startdate,enddate,1),zone=c(1,2,3,4,5),ensemble=seq(1,200,1))
foreach(
  ddate = set$day,
  setzone = set$zone,
  setensemble = set$ensemble,
  .export=c("climate_obs", "startdate","access_g_downscaled","locations","monthly_average_calculated"),
  .packages=c("dplyr","readr"),
  .noexport = setdiff(ls(),c("climate_obs", "startdate","access_g_downscaled","locations","monthly_average_calculated"))
  ) %dopar% {
  headertemplate=sprintf("[weather.met.weather]\nzonenumber = %s\nzonename  =  %s\nname  =  %s\nfday  =  %s\nfyear  =  %s\nens_id  =  %s\nlatitude = %s  (DECIMAL DEGREES)\nlongitude =  %s  (DECIMAL DEGREES)\ntav = %f (oC) ! Annual average ambient temperature\namp = %f (oC) ! Annual amplitude in mean monthly temperature.\n!\nyear day radn maxt mint rain\n()   () (MJ/m^2) (oC)  (oC)  (mm)",
                           setzone,
                           locations[[setzone]][["zonename"]],
                           locations[[setzone]][["name"]],
                           as.integer(format(as.Date(ddate), "%j")),
                           as.integer(format(as.Date(ddate), "%Y")),
                           setensemble,
                           locations[[setzone]]["center2"][[1]],
                           locations[[setzone]]["center1"][[1]],
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             mutate(
                                 daily_rain=lead(daily_rain,1),
                                 min_temp=lead(min_temp,1)
                                 )%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$tav)}),
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(
                                 Date = as.Date(datetime,format="%Y-%m-%d"),
                                 daily_rain = lead(daily_rain,1),
                                 min_temp=lead(min_temp,1)
                                 )%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$amp)})
                         )
  out = climate_obs%>%
      filter(zone==setzone)%>%
      mutate(
          Date = as.Date(datetime,format="%Y-%m-%d"),
          daily_rain = lead(daily_rain,1),
          min_temp=lead(min_temp,1)
          )%>%
    filter(Date >= startdate)%>%
    filter(Date < ddate)%>%
    select(
      Date = Date,
      rain = daily_rain,
      maxt = max_temp,
      mint = min_temp,
      radiation = radiation,
    )%>%
    mutate(
      year = as.numeric(format(Date,"%Y")),
      day = as.numeric(format(Date,"%j")),
      month = as.numeric(format(Date,"%m")) 
    )%>%
    bind_rows(
      access_g_downscaled%>%
        filter(zone == locations[[setzone]]['zonename'])%>%
        filter(ensemble == setensemble)%>%
        mutate(time_step_ahead = time_step_ahead - 1)%>%
        mutate(Date = as.Date(as.character(date),format="%Y%m%d") + time_step_ahead)%>%
        mutate(fDate = as.Date(as.character(date),format="%Y%m%d"))%>%
        filter(fDate == ddate)%>%
        mutate(
          year = as.numeric(format(Date,"%Y")),
          day = as.numeric(format(Date,"%j")),
          month = as.numeric(format(Date,"%m")),
          precip = round(precip,1),
          tmax = round(tmax,1),
          tmin = round(tmin,1),
        )%>%
         left_join(
             monthly_average_calculated%>%
                 filter(zone==setzone)%>%
                 mutate(
                     month=as.numeric(month),
                     radiation=round(radiation,1)
                     )%>%
                 select(month,radiation),
             by=("month"="month")
         )%>%
        select(
          Date = Date,
          rain = precip,
          maxt = tmax,
          mint = tmin,
          radiation= radiation,
          year = year,
          day = day,
          month = month
        )
    )
  out = out%>%
      select(
          year,
          day,
          radn=radiation,
          maxt,
          mint,
          rain
      )
  
  writeLines(
      paste(
          headertemplate,
          readr::format_delim(out,delim="  ",col_names = FALSE),
          sep="\n"
      ),
    sprintf(
        "F:/zone_pp_mets/%s_%s_%s_pp.met",
        locations[[setzone]][["zonename"]],
        ddate,
        setensemble
        )
  )
}
parallel::stopCluster(cl)

```



```{r observed mets,echo=F,message=F,warning=F,eval=F}

startdate = as.Date("2019-08-15","%Y-%m-%d")
enddate =  as.Date("2021-11-23","%Y-%m-%d")


cl=parallel::makeCluster(5)
doParallel::registerDoParallel(cl)
set = expand.grid(zone=c(1,2,3,4,5))
foreach(setzone = set$zone, .noexport = setdiff(ls(),c("climate_obs", "startdate","locations")),.packages=c("dplyr","readr")) %dopar% {
  headertemplate=sprintf("[weather.met.weather]\nzonenumber = %s\nzonename  =  %s\nname  =  %s\nlatitude = %s  (DECIMAL DEGREES)\nlongitude =  %s  (DECIMAL DEGREES)\ntav = %f (oC) ! Annual average ambient temperature\namp = %f (oC) ! Annual amplitude in mean monthly temperature.\n!\nyear day radn maxt mint rain\n()   () (MJ/m^2) (oC)  (oC)  (mm)",
                           setzone,
                           locations[[setzone]][["zonename"]],
                           locations[[setzone]][["name"]],
                           locations[[setzone]][["center2"]][1],
                           locations[[setzone]][["center1"]][1],
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             mutate(
                                 daily_rain=lead(daily_rain,1),
                                 min_temp=lead(min_temp,1)
                                 )%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$tav)}),
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(
                                 daily_rain=lead(daily_rain,1),
                                 min_temp=lead(min_temp,1)
                                 )%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$amp)})
                         )

  out = climate_obs%>%
    filter(zone == setzone)%>%
    mutate(daily_rain=lead(daily_rain,1),min_temp=lead(min_temp,1))%>%
    mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
    filter(Date >= startdate)%>%
    mutate(month = as.numeric(format(Date,"%m")))%>%
    select(
      Date = Date,
      month= month,
      rain = daily_rain,
      maxt = max_temp,
      mint = min_temp,
      radiation = radiation,
    )%>%
    mutate(
      year = as.numeric(format(Date,"%Y")),
      day = as.numeric(format(Date,"%j")),
      month = as.numeric(format(Date,"%m"))
    )
    out = out%>%
      select(
          year,
          day,
          radn=radiation,
          maxt,
          mint,
          rain
      )
    
  writeLines(
    paste(
        headertemplate,
        readr::format_delim(out,delim="  ", col_names=FALSE),
        sep="\n"
    ),
    sprintf("F:/zone_obs_mets/%s_obs.met",locations[[setzone]][["zonename"]])
  )
}
parallel::stopCluster(cl)

```



```{r No rainfall forecasts,echo=F,message=F,warning=F,eval=F}

startdate = as.Date("2019-08-15","%Y-%m-%d")
enddate =  as.Date("2021-11-23","%Y-%m-%d")


cl=parallel::makeCluster(25)
doParallel::registerDoParallel(cl)
set = expand.grid(day=seq(startdate,enddate,1),zone=c(1,2,3,4,5))
foreach(
    ddate = set$day,
    setzone = set$zone,
    .noexport=setdiff(ls(),c("climate_obs", "startdate","monthly_average_calculated","locations")),
    .packages=c("dplyr")) %dopar% {
  headertemplate=sprintf("[weather.met.weather]\nzonenumber = %s\nzonename  =  %s\nname  =  %s\nfday  =  %s\nfyear  =  %s\nlatitude = %s  (DECIMAL DEGREES)\nlongitude =  %s  (DECIMAL DEGREES)\ntav = %f (oC) ! Annual average ambient temperature\namp = %f (oC) ! Annual amplitude in mean monthly temperature.\n!\nyear day radn maxt mint rain\n()   () (MJ/m^2) (oC)  (oC)  (mm)",
                           setzone,
                           locations[[setzone]][["zonename"]],
                           locations[[setzone]][["name"]],
                           as.integer(format(as.Date(ddate), "%j")),
                           as.integer(format(as.Date(ddate), "%Y")),
                           locations[[setzone]][["center2"]][1],
                           locations[[setzone]][["center1"]][1],
                           climate_obs%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             filter(zone==setzone)%>%
                             mutate(daily_rain=lead(daily_rain,1),min_temp=lead(min_temp,1))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$tav)}),
                           climate_obs%>%
                             filter(zone==setzone)%>%
                             mutate(daily_rain=lead(daily_rain,1),min_temp=lead(min_temp,1))%>%
                             mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
                             mutate(month = format(Date,"%m"))%>%
                             mutate(year = format(Date,"%Y"))%>%
                             filter(Date <= as.Date("2010-12-31","%Y-%m-%d"))%>%
                             mutate(tav = (max_temp+min_temp)/2)%>%
                             group_by(year,month)%>%
                             summarise(tav=mean(tav))%>%
                             ungroup()%>%
                             group_by(year)%>%
                             summarise(amp = max(tav)-min(tav),tav=mean(tav))%>%
                             ungroup()%>%(function(x){mean(x$amp)})
                         )

  out = climate_obs%>%
    mutate(Date = as.Date(datetime,format="%Y-%m-%d"))%>%
    filter(zone == setzone)%>%
    mutate(daily_rain=lead(daily_rain,1),min_temp=lead(min_temp,1))%>%  
    filter(Date >= startdate)%>%
    filter(Date < ddate)%>%
    mutate(month = as.numeric(format(Date,"%m")))%>%
    select(
      Date = Date,
      month= month,
      rain = daily_rain,
      maxt = max_temp,
      mint = min_temp,
      radiation = radiation,
    )%>%
    mutate(
      year = as.numeric(format(Date,"%Y")),
      day = as.numeric(format(Date,"%j")),
      month = as.numeric(format(Date,"%m"))
    )%>%
    bind_rows(
      data.frame(Date=seq(from=ddate,to=ddate+7,by=1))%>%
        mutate(
          year = as.numeric(format(Date,"%Y")),
          day = as.numeric(format(Date,"%j")),
          month = as.numeric(format(Date,"%m")),
          rain=0,
        )%>%
         left_join(
             monthly_average_calculated%>%
                 filter(zone==setzone)%>%
                 mutate(
                     month=as.numeric(month),
                     radiation=round(radiation,1),
                     maxt=round(tmax,1),
                     mint=round(tmin,1)
                     )%>%
                 select(month,radiation,maxt,mint),
             by=("month"="month")
         )
    )
  
  out = out%>%
      select(
          year,
          day,
          radn=radiation,
          maxt,
          mint,
          rain
      )
      
  writeLines(
    paste(
        headertemplate,
        readr::format_delim(out,delim="  ",col_names=FALSE),
        sep="\n"
    ),
    sprintf("F:/zone_norain_mets/%s_%s_norain.met",locations[[setzone]][["zonename"]],ddate)
  )
}
parallel::stopCluster(cl)

```



<!--
# APSIM output conversion and storage
-->

<!--
## APSIM output converter
-->

```{r apsim forecasts converter,eval=F}
apsim_out = list.files("F:/apsim_out/","*.out",full.names = T)
apsim_obs = foreach(name=apsim_out,.combine="rbind")%do%{
  read.table(
    name,
    header = F,
    skip = 5,
    sep="",
    col.names = c(
      "Date",
      "time_steps_ahead",
      "zonename",
      "zonenumber",
      "ens_id",
      "irr_applied",
      "irrigation",
      "biomass",
      "irrig_loss",
      "popname",
      "run_off",
      "irrig_amount",
      "irrig_cutoff",
      "pawc",
      "popcutoff")
    )
}
write.csv(apsim_obs,"F:/apsim_out/apsim_blue_pp_2019.csv")
```

<!--
## APSIM output storage
-->

```{r storing apsim forecasts,eval=F}
apsim_blue_pp = read.csv("./data/apsim_blue_pp.csv")
apsim_green_pp = read.csv("./data/apsim_green_pp.csv")
apsim_grey_pp = read.csv("./data/apsim_grey_pp.csv")
apsim_red_pp = read.csv("./data/apsim_red_pp.csv")
apsim_orange_pp = read.csv("./data/apsim_orange_pp.csv")
apsim_pp = apsim_blue_pp%>%bind_rows(apsim_green_pp,apsim_grey_pp,apsim_red_pp,apsim_orange_pp)
rm(apsim_blue_pp,apsim_green_pp,apsim_grey_pp,apsim_red_pp)

apsim_obs_zones = read.csv("./data/apsim_obs_zones.csv")
apsim_noRain_zones = read.csv("./data/apsim_noRain_zones.csv")
apsim_raw_zones = read.csv("./data/apsim_raw_zones.csv")

```






